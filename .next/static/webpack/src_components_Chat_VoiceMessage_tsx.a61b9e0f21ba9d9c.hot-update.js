"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("src_components_Chat_VoiceMessage_tsx",{

/***/ "./src/hooks/useAudioPlayer.ts":
/*!*************************************!*\
  !*** ./src/hooks/useAudioPlayer.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useAudioPlayer: function() { return /* binding */ useAudioPlayer; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _service_const__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/service/const */ \"./src/service/const.ts\");\n/* harmony import */ var wavesurfer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wavesurfer.js */ \"./node_modules/wavesurfer.js/dist/wavesurfer.js\");\n\n\n\nconst useAudioPlayer = (message)=>{\n    const [audioMessage, setAudioMessage] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [isPlaying, setIsPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [currentPlayBackTime, setCurrentPlayBackTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [totalDuration, setTotalDuration] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const waveForm = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const waveFormRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const handlePlayRecording = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ()=>{\n        if (audioMessage) {\n            var _waveForm_current, _waveForm_current1;\n            (_waveForm_current = waveForm.current) === null || _waveForm_current === void 0 ? void 0 : _waveForm_current.stop();\n            (_waveForm_current1 = waveForm.current) === null || _waveForm_current1 === void 0 ? void 0 : _waveForm_current1.play();\n            await audioMessage.play();\n            setIsPlaying(true);\n        }\n    }, [\n        audioMessage\n    ]);\n    const handlePauseRecording = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        var _waveForm_current, _audioMessage;\n        (_waveForm_current = waveForm.current) === null || _waveForm_current === void 0 ? void 0 : _waveForm_current.stop();\n        (_audioMessage = audioMessage) === null || _audioMessage === void 0 ? void 0 : _audioMessage.pause();\n        setIsPlaying(false);\n    }, [\n        audioMessage\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _waveFormRef, _waveForm_current;\n        waveForm.current = wavesurfer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].create({\n            container: (_waveFormRef = waveFormRef) === null || _waveFormRef === void 0 ? void 0 : _waveFormRef.current,\n            waveColor: \"#ccc\",\n            progressColor: \"#4a9eff\",\n            cursorColor: \"#435766\",\n            barWidth: 2,\n            height: 30\n        });\n        (_waveForm_current = waveForm.current) === null || _waveForm_current === void 0 ? void 0 : _waveForm_current.on(\"finish\", ()=>setIsPlaying(false));\n        return ()=>{\n            var _waveForm_current;\n            return (_waveForm_current = waveForm.current) === null || _waveForm_current === void 0 ? void 0 : _waveForm_current.destroy();\n        };\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        if (audioMessage) {\n            const updatePlayBackTime = ()=>setCurrentPlayBackTime(audioMessage.currentTime);\n            audioMessage.addEventListener(\"timeupdate\", updatePlayBackTime);\n            return ()=>{\n                var _audioMessage;\n                (_audioMessage = audioMessage) === null || _audioMessage === void 0 ? void 0 : _audioMessage.removeEventListener(\"timeupdate\", updatePlayBackTime);\n            };\n        }\n    }, [\n        audioMessage\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _waveForm_current, _waveForm_current1;\n        const audioURL = \"\".concat(_service_const__WEBPACK_IMPORTED_MODULE_1__.HOST, \"/\").concat(message.message);\n        const audio = new Audio(audioURL);\n        setAudioMessage(audio);\n        (_waveForm_current = waveForm.current) === null || _waveForm_current === void 0 ? void 0 : _waveForm_current.load(audioURL);\n        (_waveForm_current1 = waveForm.current) === null || _waveForm_current1 === void 0 ? void 0 : _waveForm_current1.on(\"ready\", ()=>{\n            var _waveForm_current;\n            setTotalDuration(Number((_waveForm_current = waveForm.current) === null || _waveForm_current === void 0 ? void 0 : _waveForm_current.getDuration()));\n        });\n    }, [\n        message.message\n    ]);\n    return {\n        state: {\n            audioMessage,\n            isPlaying,\n            currentPlayBackTime,\n            totalDuration\n        },\n        audioFn: {\n            handlePlayRecording,\n            handlePauseRecording\n        },\n        refs: {\n            waveForm,\n            waveFormRef\n        }\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaG9va3MvdXNlQXVkaW9QbGF5ZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFNYztBQUV3QjtBQUNBO0FBRS9CLE1BQU1NLGlCQUFpQixDQUFDQztJQUM5QixNQUFNLENBQUNDLGNBQWNDLGdCQUFnQixHQUFHTiwrQ0FBUUEsQ0FDL0M7SUFFRCxNQUFNLENBQUNPLFdBQVdDLGFBQWEsR0FBR1IsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDUyxxQkFBcUJDLHVCQUF1QixHQUFHViwrQ0FBUUEsQ0FBUztJQUN2RSxNQUFNLENBQUNXLGVBQWVDLGlCQUFpQixHQUFHWiwrQ0FBUUEsQ0FBUztJQUUzRCxNQUFNYSxXQUFnRGQsNkNBQU1BLENBQUM7SUFDN0QsTUFBTWUsY0FBdURmLDZDQUFNQSxDQUFDO0lBRXBFLE1BQU1nQixzQkFBc0JsQixrREFBV0EsQ0FBQztRQUN2QyxJQUFJUSxjQUFjO2dCQUNqQlEsbUJBQ0FBO2FBREFBLG9CQUFBQSxTQUFTRyxPQUFPLGNBQWhCSCx3Q0FBQUEsa0JBQWtCSSxJQUFJO2FBQ3RCSixxQkFBQUEsU0FBU0csT0FBTyxjQUFoQkgseUNBQUFBLG1CQUFrQkssSUFBSTtZQUN0QixNQUFNYixhQUFhYSxJQUFJO1lBQ3ZCVixhQUFhO1FBQ2Q7SUFDRCxHQUFHO1FBQUNIO0tBQWE7SUFDakIsTUFBTWMsdUJBQXVCdEIsa0RBQVdBLENBQUM7WUFDeENnQixtQkFDQVI7U0FEQVEsb0JBQUFBLFNBQVNHLE9BQU8sY0FBaEJILHdDQUFBQSxrQkFBa0JJLElBQUk7U0FDdEJaLGdCQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWNlLEtBQUs7UUFDbkJaLGFBQWE7SUFDZCxHQUFHO1FBQUNIO0tBQWE7SUFDakJQLGdEQUFTQSxDQUFDO1lBRUlnQixjQU9aRDtRQVJBQSxTQUFTRyxPQUFPLEdBQUdkLDREQUFpQixDQUFDO1lBQ3BDb0IsU0FBUyxHQUFFUixlQUFBQSx5QkFBQUEsbUNBQUFBLGFBQWFFLE9BQU87WUFDL0JPLFdBQVc7WUFDWEMsZUFBZTtZQUNmQyxhQUFhO1lBQ2JDLFVBQVU7WUFDVkMsUUFBUTtRQUNUO1NBQ0FkLG9CQUFBQSxTQUFTRyxPQUFPLGNBQWhCSCx3Q0FBQUEsa0JBQWtCZSxFQUFFLENBQUMsVUFBVSxJQUFNcEIsYUFBYTtRQUNsRCxPQUFPO2dCQUFNSztvQkFBQUEsb0JBQUFBLFNBQVNHLE9BQU8sY0FBaEJILHdDQUFBQSxrQkFBa0JnQixPQUFPOztJQUN4QyxHQUFHLEVBQUU7SUFDTC9CLGdEQUFTQSxDQUFDO1FBQ1QsSUFBSU8sY0FBYztZQUNqQixNQUFNeUIscUJBQXFCLElBQzFCcEIsdUJBQXVCTCxhQUFhMEIsV0FBVztZQUNoRDFCLGFBQWEyQixnQkFBZ0IsQ0FBQyxjQUFjRjtZQUM1QyxPQUFPO29CQUNOekI7aUJBQUFBLGdCQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWM0QixtQkFBbUIsQ0FDaEMsY0FDQUg7WUFFRjtRQUNEO0lBQ0QsR0FBRztRQUFDekI7S0FBYTtJQUVqQlAsZ0RBQVNBLENBQUM7WUFJVGUsbUJBQ0FBO1FBSkEsTUFBTXFCLFdBQVcsR0FBVzlCLE9BQVJILGdEQUFJQSxFQUFDLEtBQW1CLE9BQWhCRyxRQUFRQSxPQUFPO1FBQzNDLE1BQU0rQixRQUFRLElBQUlDLE1BQU1GO1FBQ3hCNUIsZ0JBQWdCNkI7U0FDaEJ0QixvQkFBQUEsU0FBU0csT0FBTyxjQUFoQkgsd0NBQUFBLGtCQUFrQndCLElBQUksQ0FBQ0g7U0FDdkJyQixxQkFBQUEsU0FBU0csT0FBTyxjQUFoQkgseUNBQUFBLG1CQUFrQmUsRUFBRSxDQUFDLFNBQVM7Z0JBQ0xmO1lBQXhCRCxpQkFBaUIwQixRQUFPekIsb0JBQUFBLFNBQVNHLE9BQU8sY0FBaEJILHdDQUFBQSxrQkFBa0IwQixXQUFXO1FBQ3REO0lBQ0QsR0FBRztRQUFDbkMsUUFBUUEsT0FBTztLQUFDO0lBRXBCLE9BQU87UUFDTm9DLE9BQU87WUFBRW5DO1lBQWNFO1lBQVdFO1lBQXFCRTtRQUFjO1FBQ3JFOEIsU0FBUztZQUFFMUI7WUFBcUJJO1FBQXFCO1FBQ3JEdUIsTUFBTTtZQUFFN0I7WUFBVUM7UUFBWTtJQUMvQjtBQUNELEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2hvb2tzL3VzZUF1ZGlvUGxheWVyLnRzPzY5NTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcblx0TXV0YWJsZVJlZk9iamVjdCxcblx0dXNlQ2FsbGJhY2ssXG5cdHVzZUVmZmVjdCxcblx0dXNlUmVmLFxuXHR1c2VTdGF0ZVxufSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IElNZXNzYWdlIH0gZnJvbSAnQC9zdG9yZS9tZXNzYWdlL21lc3NhZ2UudHlwZXMnXG5pbXBvcnQgeyBIT1NUIH0gZnJvbSAnQC9zZXJ2aWNlL2NvbnN0J1xuaW1wb3J0IFdhdmVTdXJmZXIgZnJvbSAnd2F2ZXN1cmZlci5qcydcblxuZXhwb3J0IGNvbnN0IHVzZUF1ZGlvUGxheWVyID0gKG1lc3NhZ2U6IElNZXNzYWdlKSA9PiB7XG5cdGNvbnN0IFthdWRpb01lc3NhZ2UsIHNldEF1ZGlvTWVzc2FnZV0gPSB1c2VTdGF0ZTxIVE1MQXVkaW9FbGVtZW50IHwgbnVsbD4oXG5cdFx0bnVsbFxuXHQpXG5cdGNvbnN0IFtpc1BsYXlpbmcsIHNldElzUGxheWluZ10gPSB1c2VTdGF0ZShmYWxzZSlcblx0Y29uc3QgW2N1cnJlbnRQbGF5QmFja1RpbWUsIHNldEN1cnJlbnRQbGF5QmFja1RpbWVdID0gdXNlU3RhdGU8bnVtYmVyPigwKVxuXHRjb25zdCBbdG90YWxEdXJhdGlvbiwgc2V0VG90YWxEdXJhdGlvbl0gPSB1c2VTdGF0ZTxudW1iZXI+KDApXG5cblx0Y29uc3Qgd2F2ZUZvcm06IE11dGFibGVSZWZPYmplY3Q8V2F2ZVN1cmZlciB8IG51bGw+ID0gdXNlUmVmKG51bGwpXG5cdGNvbnN0IHdhdmVGb3JtUmVmOiBNdXRhYmxlUmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50IHwgbnVsbD4gPSB1c2VSZWYobnVsbClcblxuXHRjb25zdCBoYW5kbGVQbGF5UmVjb3JkaW5nID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuXHRcdGlmIChhdWRpb01lc3NhZ2UpIHtcblx0XHRcdHdhdmVGb3JtLmN1cnJlbnQ/LnN0b3AoKVxuXHRcdFx0d2F2ZUZvcm0uY3VycmVudD8ucGxheSgpXG5cdFx0XHRhd2FpdCBhdWRpb01lc3NhZ2UucGxheSgpXG5cdFx0XHRzZXRJc1BsYXlpbmcodHJ1ZSlcblx0XHR9XG5cdH0sIFthdWRpb01lc3NhZ2VdKVxuXHRjb25zdCBoYW5kbGVQYXVzZVJlY29yZGluZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcblx0XHR3YXZlRm9ybS5jdXJyZW50Py5zdG9wKClcblx0XHRhdWRpb01lc3NhZ2U/LnBhdXNlKClcblx0XHRzZXRJc1BsYXlpbmcoZmFsc2UpXG5cdH0sIFthdWRpb01lc3NhZ2VdKVxuXHR1c2VFZmZlY3QoKCkgPT4ge1xuXHRcdFx0d2F2ZUZvcm0uY3VycmVudCA9IFdhdmVTdXJmZXIuY3JlYXRlKHtcblx0XHRcdFx0Y29udGFpbmVyOiB3YXZlRm9ybVJlZj8uY3VycmVudCBhcyBzdHJpbmcgfCBIVE1MRWxlbWVudCxcblx0XHRcdFx0d2F2ZUNvbG9yOiAnI2NjYycsXG5cdFx0XHRcdHByb2dyZXNzQ29sb3I6ICcjNGE5ZWZmJyxcblx0XHRcdFx0Y3Vyc29yQ29sb3I6ICcjNDM1NzY2Jyxcblx0XHRcdFx0YmFyV2lkdGg6IDIsXG5cdFx0XHRcdGhlaWdodDogMzBcblx0XHRcdH0pXG5cdFx0XHR3YXZlRm9ybS5jdXJyZW50Py5vbignZmluaXNoJywgKCkgPT4gc2V0SXNQbGF5aW5nKGZhbHNlKSlcblx0XHRcdHJldHVybiAoKSA9PiB3YXZlRm9ybS5jdXJyZW50Py5kZXN0cm95KClcblx0fSwgW10pXG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0aWYgKGF1ZGlvTWVzc2FnZSkge1xuXHRcdFx0Y29uc3QgdXBkYXRlUGxheUJhY2tUaW1lID0gKCkgPT5cblx0XHRcdFx0c2V0Q3VycmVudFBsYXlCYWNrVGltZShhdWRpb01lc3NhZ2UuY3VycmVudFRpbWUpXG5cdFx0XHRhdWRpb01lc3NhZ2UuYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHVwZGF0ZVBsYXlCYWNrVGltZSlcblx0XHRcdHJldHVybiAoKSA9PiB7XG5cdFx0XHRcdGF1ZGlvTWVzc2FnZT8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcblx0XHRcdFx0XHQndGltZXVwZGF0ZScsXG5cdFx0XHRcdFx0dXBkYXRlUGxheUJhY2tUaW1lXG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHR9XG5cdH0sIFthdWRpb01lc3NhZ2VdKVxuXG5cdHVzZUVmZmVjdCgoKSA9PiB7XG5cdFx0Y29uc3QgYXVkaW9VUkwgPSBgJHtIT1NUfS8ke21lc3NhZ2UubWVzc2FnZX1gXG5cdFx0Y29uc3QgYXVkaW8gPSBuZXcgQXVkaW8oYXVkaW9VUkwpXG5cdFx0c2V0QXVkaW9NZXNzYWdlKGF1ZGlvKVxuXHRcdHdhdmVGb3JtLmN1cnJlbnQ/LmxvYWQoYXVkaW9VUkwpXG5cdFx0d2F2ZUZvcm0uY3VycmVudD8ub24oJ3JlYWR5JywgKCkgPT4ge1xuXHRcdFx0c2V0VG90YWxEdXJhdGlvbihOdW1iZXIod2F2ZUZvcm0uY3VycmVudD8uZ2V0RHVyYXRpb24oKSkpXG5cdFx0fSlcblx0fSwgW21lc3NhZ2UubWVzc2FnZV0pXG5cblx0cmV0dXJuIHtcblx0XHRzdGF0ZTogeyBhdWRpb01lc3NhZ2UsIGlzUGxheWluZywgY3VycmVudFBsYXlCYWNrVGltZSwgdG90YWxEdXJhdGlvbiB9LFxuXHRcdGF1ZGlvRm46IHsgaGFuZGxlUGxheVJlY29yZGluZywgaGFuZGxlUGF1c2VSZWNvcmRpbmcgfSxcblx0XHRyZWZzOiB7IHdhdmVGb3JtLCB3YXZlRm9ybVJlZiB9XG5cdH1cbn1cbiJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwiSE9TVCIsIldhdmVTdXJmZXIiLCJ1c2VBdWRpb1BsYXllciIsIm1lc3NhZ2UiLCJhdWRpb01lc3NhZ2UiLCJzZXRBdWRpb01lc3NhZ2UiLCJpc1BsYXlpbmciLCJzZXRJc1BsYXlpbmciLCJjdXJyZW50UGxheUJhY2tUaW1lIiwic2V0Q3VycmVudFBsYXlCYWNrVGltZSIsInRvdGFsRHVyYXRpb24iLCJzZXRUb3RhbER1cmF0aW9uIiwid2F2ZUZvcm0iLCJ3YXZlRm9ybVJlZiIsImhhbmRsZVBsYXlSZWNvcmRpbmciLCJjdXJyZW50Iiwic3RvcCIsInBsYXkiLCJoYW5kbGVQYXVzZVJlY29yZGluZyIsInBhdXNlIiwiY3JlYXRlIiwiY29udGFpbmVyIiwid2F2ZUNvbG9yIiwicHJvZ3Jlc3NDb2xvciIsImN1cnNvckNvbG9yIiwiYmFyV2lkdGgiLCJoZWlnaHQiLCJvbiIsImRlc3Ryb3kiLCJ1cGRhdGVQbGF5QmFja1RpbWUiLCJjdXJyZW50VGltZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYXVkaW9VUkwiLCJhdWRpbyIsIkF1ZGlvIiwibG9hZCIsIk51bWJlciIsImdldER1cmF0aW9uIiwic3RhdGUiLCJhdWRpb0ZuIiwicmVmcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/hooks/useAudioPlayer.ts\n"));

/***/ }),

/***/ "./node_modules/wavesurfer.js/dist/decoder.js":
/*!****************************************************!*\
  !*** ./node_modules/wavesurfer.js/dist/decoder.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/** Decode an array buffer into an audio buffer */\nfunction decode(audioData, sampleRate) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const audioCtx = new AudioContext({ sampleRate });\n        const decode = audioCtx.decodeAudioData(audioData);\n        return decode.finally(() => audioCtx.close());\n    });\n}\n/** Normalize peaks to -1..1 */\nfunction normalize(channelData) {\n    const firstChannel = channelData[0];\n    if (firstChannel.some((n) => n > 1 || n < -1)) {\n        const length = firstChannel.length;\n        let max = 0;\n        for (let i = 0; i < length; i++) {\n            const absN = Math.abs(firstChannel[i]);\n            if (absN > max)\n                max = absN;\n        }\n        for (const channel of channelData) {\n            for (let i = 0; i < length; i++) {\n                channel[i] /= max;\n            }\n        }\n    }\n    return channelData;\n}\n/** Create an audio buffer from pre-decoded audio data */\nfunction createBuffer(channelData, duration) {\n    // If a single array of numbers is passed, make it an array of arrays\n    if (typeof channelData[0] === 'number')\n        channelData = [channelData];\n    // Normalize to -1..1\n    normalize(channelData);\n    return {\n        duration,\n        length: channelData[0].length,\n        sampleRate: channelData[0].length / duration,\n        numberOfChannels: channelData.length,\n        getChannelData: (i) => channelData === null || channelData === void 0 ? void 0 : channelData[i],\n        copyFromChannel: AudioBuffer.prototype.copyFromChannel,\n        copyToChannel: AudioBuffer.prototype.copyToChannel,\n    };\n}\nconst Decoder = {\n    decode,\n    createBuffer,\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Decoder);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L2RlY29kZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxZQUFZO0FBQ3hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQWUsT0FBTyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3QvZGVjb2Rlci5qcz85OWI1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuLyoqIERlY29kZSBhbiBhcnJheSBidWZmZXIgaW50byBhbiBhdWRpbyBidWZmZXIgKi9cbmZ1bmN0aW9uIGRlY29kZShhdWRpb0RhdGEsIHNhbXBsZVJhdGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBhdWRpb0N0eCA9IG5ldyBBdWRpb0NvbnRleHQoeyBzYW1wbGVSYXRlIH0pO1xuICAgICAgICBjb25zdCBkZWNvZGUgPSBhdWRpb0N0eC5kZWNvZGVBdWRpb0RhdGEoYXVkaW9EYXRhKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZS5maW5hbGx5KCgpID0+IGF1ZGlvQ3R4LmNsb3NlKCkpO1xuICAgIH0pO1xufVxuLyoqIE5vcm1hbGl6ZSBwZWFrcyB0byAtMS4uMSAqL1xuZnVuY3Rpb24gbm9ybWFsaXplKGNoYW5uZWxEYXRhKSB7XG4gICAgY29uc3QgZmlyc3RDaGFubmVsID0gY2hhbm5lbERhdGFbMF07XG4gICAgaWYgKGZpcnN0Q2hhbm5lbC5zb21lKChuKSA9PiBuID4gMSB8fCBuIDwgLTEpKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGZpcnN0Q2hhbm5lbC5sZW5ndGg7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhYnNOID0gTWF0aC5hYnMoZmlyc3RDaGFubmVsW2ldKTtcbiAgICAgICAgICAgIGlmIChhYnNOID4gbWF4KVxuICAgICAgICAgICAgICAgIG1heCA9IGFic047XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBjaGFubmVsIG9mIGNoYW5uZWxEYXRhKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbFtpXSAvPSBtYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWxEYXRhO1xufVxuLyoqIENyZWF0ZSBhbiBhdWRpbyBidWZmZXIgZnJvbSBwcmUtZGVjb2RlZCBhdWRpbyBkYXRhICovXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIoY2hhbm5lbERhdGEsIGR1cmF0aW9uKSB7XG4gICAgLy8gSWYgYSBzaW5nbGUgYXJyYXkgb2YgbnVtYmVycyBpcyBwYXNzZWQsIG1ha2UgaXQgYW4gYXJyYXkgb2YgYXJyYXlzXG4gICAgaWYgKHR5cGVvZiBjaGFubmVsRGF0YVswXSA9PT0gJ251bWJlcicpXG4gICAgICAgIGNoYW5uZWxEYXRhID0gW2NoYW5uZWxEYXRhXTtcbiAgICAvLyBOb3JtYWxpemUgdG8gLTEuLjFcbiAgICBub3JtYWxpemUoY2hhbm5lbERhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBsZW5ndGg6IGNoYW5uZWxEYXRhWzBdLmxlbmd0aCxcbiAgICAgICAgc2FtcGxlUmF0ZTogY2hhbm5lbERhdGFbMF0ubGVuZ3RoIC8gZHVyYXRpb24sXG4gICAgICAgIG51bWJlck9mQ2hhbm5lbHM6IGNoYW5uZWxEYXRhLmxlbmd0aCxcbiAgICAgICAgZ2V0Q2hhbm5lbERhdGE6IChpKSA9PiBjaGFubmVsRGF0YSA9PT0gbnVsbCB8fCBjaGFubmVsRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbERhdGFbaV0sXG4gICAgICAgIGNvcHlGcm9tQ2hhbm5lbDogQXVkaW9CdWZmZXIucHJvdG90eXBlLmNvcHlGcm9tQ2hhbm5lbCxcbiAgICAgICAgY29weVRvQ2hhbm5lbDogQXVkaW9CdWZmZXIucHJvdG90eXBlLmNvcHlUb0NoYW5uZWwsXG4gICAgfTtcbn1cbmNvbnN0IERlY29kZXIgPSB7XG4gICAgZGVjb2RlLFxuICAgIGNyZWF0ZUJ1ZmZlcixcbn07XG5leHBvcnQgZGVmYXVsdCBEZWNvZGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/wavesurfer.js/dist/decoder.js\n"));

/***/ }),

/***/ "./node_modules/wavesurfer.js/dist/draggable.js":
/*!******************************************************!*\
  !*** ./node_modules/wavesurfer.js/dist/draggable.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   makeDraggable: function() { return /* binding */ makeDraggable; }\n/* harmony export */ });\nfunction makeDraggable(element, onDrag, onStart, onEnd, threshold = 5) {\n    let unsub = () => {\n        return;\n    };\n    if (!element)\n        return unsub;\n    const down = (e) => {\n        // Ignore the right mouse button\n        if (e.button === 2)\n            return;\n        e.preventDefault();\n        e.stopPropagation();\n        let startX = e.clientX;\n        let startY = e.clientY;\n        let isDragging = false;\n        const move = (e) => {\n            e.preventDefault();\n            e.stopPropagation();\n            const x = e.clientX;\n            const y = e.clientY;\n            if (isDragging || Math.abs(x - startX) >= threshold || Math.abs(y - startY) >= threshold) {\n                const { left, top } = element.getBoundingClientRect();\n                if (!isDragging) {\n                    isDragging = true;\n                    onStart === null || onStart === void 0 ? void 0 : onStart(startX - left, startY - top);\n                }\n                onDrag(x - startX, y - startY, x - left, y - top);\n                startX = x;\n                startY = y;\n            }\n        };\n        const click = (e) => {\n            if (isDragging) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        };\n        const up = () => {\n            if (isDragging) {\n                onEnd === null || onEnd === void 0 ? void 0 : onEnd();\n            }\n            unsub();\n        };\n        document.addEventListener('pointermove', move);\n        document.addEventListener('pointerup', up);\n        document.addEventListener('pointerleave', up);\n        document.addEventListener('click', click, true);\n        unsub = () => {\n            document.removeEventListener('pointermove', move);\n            document.removeEventListener('pointerup', up);\n            document.removeEventListener('pointerleave', up);\n            setTimeout(() => {\n                document.removeEventListener('click', click, true);\n            }, 10);\n        };\n    };\n    element.addEventListener('pointerdown', down);\n    return () => {\n        unsub();\n        element.removeEventListener('pointerdown', down);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L2RyYWdnYWJsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L2RyYWdnYWJsZS5qcz80MjkyIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBtYWtlRHJhZ2dhYmxlKGVsZW1lbnQsIG9uRHJhZywgb25TdGFydCwgb25FbmQsIHRocmVzaG9sZCA9IDUpIHtcbiAgICBsZXQgdW5zdWIgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuICAgIGlmICghZWxlbWVudClcbiAgICAgICAgcmV0dXJuIHVuc3ViO1xuICAgIGNvbnN0IGRvd24gPSAoZSkgPT4ge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIHJpZ2h0IG1vdXNlIGJ1dHRvblxuICAgICAgICBpZiAoZS5idXR0b24gPT09IDIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgbGV0IHN0YXJ0WCA9IGUuY2xpZW50WDtcbiAgICAgICAgbGV0IHN0YXJ0WSA9IGUuY2xpZW50WTtcbiAgICAgICAgbGV0IGlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbW92ZSA9IChlKSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgeCA9IGUuY2xpZW50WDtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBlLmNsaWVudFk7XG4gICAgICAgICAgICBpZiAoaXNEcmFnZ2luZyB8fCBNYXRoLmFicyh4IC0gc3RhcnRYKSA+PSB0aHJlc2hvbGQgfHwgTWF0aC5hYnMoeSAtIHN0YXJ0WSkgPj0gdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBsZWZ0LCB0b3AgfSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvblN0YXJ0ID09PSBudWxsIHx8IG9uU3RhcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uU3RhcnQoc3RhcnRYIC0gbGVmdCwgc3RhcnRZIC0gdG9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25EcmFnKHggLSBzdGFydFgsIHkgLSBzdGFydFksIHggLSBsZWZ0LCB5IC0gdG9wKTtcbiAgICAgICAgICAgICAgICBzdGFydFggPSB4O1xuICAgICAgICAgICAgICAgIHN0YXJ0WSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVwID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgICAgICBvbkVuZCA9PT0gbnVsbCB8fCBvbkVuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuc3ViKCk7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgbW92ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHVwKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxlYXZlJywgdXApO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrLCB0cnVlKTtcbiAgICAgICAgdW5zdWIgPSAoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG1vdmUpO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdXApO1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxlYXZlJywgdXApO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGljaywgdHJ1ZSk7XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgZG93bik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdW5zdWIoKTtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGRvd24pO1xuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/wavesurfer.js/dist/draggable.js\n"));

/***/ }),

/***/ "./node_modules/wavesurfer.js/dist/event-emitter.js":
/*!**********************************************************!*\
  !*** ./node_modules/wavesurfer.js/dist/event-emitter.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/** A simple event emitter that can be used to listen to and emit events. */\nclass EventEmitter {\n    constructor() {\n        this.listeners = {};\n    }\n    /** Subscribe to an event. Returns an unsubscribe function. */\n    on(eventName, listener) {\n        if (!this.listeners[eventName]) {\n            this.listeners[eventName] = new Set();\n        }\n        this.listeners[eventName].add(listener);\n        return () => this.un(eventName, listener);\n    }\n    /** Subscribe to an event only once */\n    once(eventName, listener) {\n        // The actual subscription\n        const unsubscribe = this.on(eventName, listener);\n        // Another subscription that will unsubscribe the actual subscription and itself after the first event\n        const unsubscribeOnce = this.on(eventName, () => {\n            unsubscribe();\n            unsubscribeOnce();\n        });\n        return unsubscribe;\n    }\n    /** Unsubscribe from an event */\n    un(eventName, listener) {\n        if (this.listeners[eventName]) {\n            if (listener) {\n                this.listeners[eventName].delete(listener);\n            }\n            else {\n                delete this.listeners[eventName];\n            }\n        }\n    }\n    /** Clear all events */\n    unAll() {\n        this.listeners = {};\n    }\n    /** Emit an event */\n    emit(eventName, ...args) {\n        if (this.listeners[eventName]) {\n            this.listeners[eventName].forEach((listener) => listener(...args));\n        }\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (EventEmitter);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L2V2ZW50LWVtaXR0ZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBZSxZQUFZLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3dhdmVzdXJmZXIuanMvZGlzdC9ldmVudC1lbWl0dGVyLmpzP2Y0ZWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEEgc2ltcGxlIGV2ZW50IGVtaXR0ZXIgdGhhdCBjYW4gYmUgdXNlZCB0byBsaXN0ZW4gdG8gYW5kIGVtaXQgZXZlbnRzLiAqL1xuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgLyoqIFN1YnNjcmliZSB0byBhbiBldmVudC4gUmV0dXJucyBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbi4gKi9cbiAgICBvbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdLmFkZChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLnVuKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKiogU3Vic2NyaWJlIHRvIGFuIGV2ZW50IG9ubHkgb25jZSAqL1xuICAgIG9uY2UoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICAvLyBUaGUgYWN0dWFsIHN1YnNjcmlwdGlvblxuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgIC8vIEFub3RoZXIgc3Vic2NyaXB0aW9uIHRoYXQgd2lsbCB1bnN1YnNjcmliZSB0aGUgYWN0dWFsIHN1YnNjcmlwdGlvbiBhbmQgaXRzZWxmIGFmdGVyIHRoZSBmaXJzdCBldmVudFxuICAgICAgICBjb25zdCB1bnN1YnNjcmliZU9uY2UgPSB0aGlzLm9uKGV2ZW50TmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlT25jZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICAgIH1cbiAgICAvKiogVW5zdWJzY3JpYmUgZnJvbSBhbiBldmVudCAqL1xuICAgIHVuKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0uZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBDbGVhciBhbGwgZXZlbnRzICovXG4gICAgdW5BbGwoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIC8qKiBFbWl0IGFuIGV2ZW50ICovXG4gICAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV0uZm9yRWFjaCgobGlzdGVuZXIpID0+IGxpc3RlbmVyKC4uLmFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEV2ZW50RW1pdHRlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/wavesurfer.js/dist/event-emitter.js\n"));

/***/ }),

/***/ "./node_modules/wavesurfer.js/dist/fetcher.js":
/*!****************************************************!*\
  !*** ./node_modules/wavesurfer.js/dist/fetcher.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction fetchBlob(url, progressCallback, requestInit) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n        // Fetch the resource\n        const response = yield fetch(url, requestInit);\n        // Read the data to track progress\n        {\n            const reader = (_a = response.clone().body) === null || _a === void 0 ? void 0 : _a.getReader();\n            const contentLength = Number((_b = response.headers) === null || _b === void 0 ? void 0 : _b.get('Content-Length'));\n            let receivedLength = 0;\n            // Process the data\n            const processChunk = (done, value) => __awaiter(this, void 0, void 0, function* () {\n                if (done)\n                    return;\n                // Add to the received length\n                receivedLength += (value === null || value === void 0 ? void 0 : value.length) || 0;\n                const percentage = Math.round((receivedLength / contentLength) * 100);\n                progressCallback(percentage);\n                // Continue reading data\n                return reader === null || reader === void 0 ? void 0 : reader.read().then(({ done, value }) => processChunk(done, value));\n            });\n            reader === null || reader === void 0 ? void 0 : reader.read().then(({ done, value }) => processChunk(done, value));\n        }\n        return response.blob();\n    });\n}\nconst Fetcher = {\n    fetchBlob,\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Fetcher);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L2ZldGNoZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLGFBQWE7QUFDMUcsYUFBYTtBQUNiLGtGQUFrRixhQUFhO0FBQy9GO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBZSxPQUFPLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3dhdmVzdXJmZXIuanMvZGlzdC9mZXRjaGVyLmpzPzBjZjAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBmZXRjaEJsb2IodXJsLCBwcm9ncmVzc0NhbGxiYWNrLCByZXF1ZXN0SW5pdCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgLy8gRmV0Y2ggdGhlIHJlc291cmNlXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgZmV0Y2godXJsLCByZXF1ZXN0SW5pdCk7XG4gICAgICAgIC8vIFJlYWQgdGhlIGRhdGEgdG8gdHJhY2sgcHJvZ3Jlc3NcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gKF9hID0gcmVzcG9uc2UuY2xvbmUoKS5ib2R5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gTnVtYmVyKChfYiA9IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQoJ0NvbnRlbnQtTGVuZ3RoJykpO1xuICAgICAgICAgICAgbGV0IHJlY2VpdmVkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NDaHVuayA9IChkb25lLCB2YWx1ZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSByZWNlaXZlZCBsZW5ndGhcbiAgICAgICAgICAgICAgICByZWNlaXZlZExlbmd0aCArPSAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gTWF0aC5yb3VuZCgocmVjZWl2ZWRMZW5ndGggLyBjb250ZW50TGVuZ3RoKSAqIDEwMCk7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayhwZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSByZWFkaW5nIGRhdGFcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyID09PSBudWxsIHx8IHJlYWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVhZGVyLnJlYWQoKS50aGVuKCh7IGRvbmUsIHZhbHVlIH0pID0+IHByb2Nlc3NDaHVuayhkb25lLCB2YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWFkZXIgPT09IG51bGwgfHwgcmVhZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWFkZXIucmVhZCgpLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4gcHJvY2Vzc0NodW5rKGRvbmUsIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKTtcbiAgICB9KTtcbn1cbmNvbnN0IEZldGNoZXIgPSB7XG4gICAgZmV0Y2hCbG9iLFxufTtcbmV4cG9ydCBkZWZhdWx0IEZldGNoZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/wavesurfer.js/dist/fetcher.js\n"));

/***/ }),

/***/ "./node_modules/wavesurfer.js/dist/player.js":
/*!***************************************************!*\
  !*** ./node_modules/wavesurfer.js/dist/player.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _event_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-emitter.js */ \"./node_modules/wavesurfer.js/dist/event-emitter.js\");\n\nclass Player extends _event_emitter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(options) {\n        super();\n        if (options.media) {\n            this.media = options.media;\n        }\n        else {\n            this.media = document.createElement('audio');\n        }\n        // Controls\n        if (options.mediaControls) {\n            this.media.controls = true;\n        }\n        // Autoplay\n        if (options.autoplay) {\n            this.media.autoplay = true;\n        }\n        // Speed\n        if (options.playbackRate != null) {\n            this.onceMediaEvent('canplay', () => {\n                if (options.playbackRate != null) {\n                    this.media.playbackRate = options.playbackRate;\n                }\n            });\n        }\n    }\n    onMediaEvent(event, callback, options) {\n        this.media.addEventListener(event, callback, options);\n        return () => this.media.removeEventListener(event, callback);\n    }\n    onceMediaEvent(event, callback) {\n        return this.onMediaEvent(event, callback, { once: true });\n    }\n    getSrc() {\n        return this.media.currentSrc || this.media.src || '';\n    }\n    revokeSrc() {\n        const src = this.getSrc();\n        if (src.startsWith('blob:')) {\n            URL.revokeObjectURL(src);\n        }\n    }\n    setSrc(url, blob) {\n        const src = this.getSrc();\n        if (src === url)\n            return;\n        this.revokeSrc();\n        const newSrc = blob instanceof Blob ? URL.createObjectURL(blob) : url;\n        this.media.src = newSrc;\n        this.media.load();\n    }\n    destroy() {\n        this.media.pause();\n        this.revokeSrc();\n        this.media.src = '';\n        // Load resets the media element to its initial state\n        this.media.load();\n    }\n    /** Start playing the audio */\n    play() {\n        return this.media.play();\n    }\n    /** Pause the audio */\n    pause() {\n        this.media.pause();\n    }\n    /** Check if the audio is playing */\n    isPlaying() {\n        return this.media.currentTime > 0 && !this.media.paused && !this.media.ended;\n    }\n    /** Jumpt to a specific time in the audio (in seconds) */\n    setTime(time) {\n        this.media.currentTime = time;\n    }\n    /** Get the duration of the audio in seconds */\n    getDuration() {\n        return this.media.duration;\n    }\n    /** Get the current audio position in seconds */\n    getCurrentTime() {\n        return this.media.currentTime;\n    }\n    /** Get the audio volume */\n    getVolume() {\n        return this.media.volume;\n    }\n    /** Set the audio volume */\n    setVolume(volume) {\n        this.media.volume = volume;\n    }\n    /** Get the audio muted state */\n    getMuted() {\n        return this.media.muted;\n    }\n    /** Mute or unmute the audio */\n    setMuted(muted) {\n        this.media.muted = muted;\n    }\n    /** Get the playback speed */\n    getPlaybackRate() {\n        return this.media.playbackRate;\n    }\n    /** Set the playback speed, pass an optional false to NOT preserve the pitch */\n    setPlaybackRate(rate, preservePitch) {\n        // preservePitch is true by default in most browsers\n        if (preservePitch != null) {\n            this.media.preservesPitch = preservePitch;\n        }\n        this.media.playbackRate = rate;\n    }\n    /** Get the HTML media element */\n    getMediaElement() {\n        return this.media;\n    }\n    /** Set a sink id to change the audio output device */\n    setSinkId(sinkId) {\n        // See https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId\n        const media = this.media;\n        return media.setSinkId(sinkId);\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Player);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3BsYXllci5qcyIsIm1hcHBpbmdzIjoiOztBQUE4QztBQUM5QyxxQkFBcUIseURBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsWUFBWTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQWUsTUFBTSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3QvcGxheWVyLmpzPzRjOWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuL2V2ZW50LWVtaXR0ZXIuanMnO1xuY2xhc3MgUGxheWVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChvcHRpb25zLm1lZGlhKSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhID0gb3B0aW9ucy5tZWRpYTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnRyb2xzXG4gICAgICAgIGlmIChvcHRpb25zLm1lZGlhQ29udHJvbHMpIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWEuY29udHJvbHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEF1dG9wbGF5XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9wbGF5KSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGVlZFxuICAgICAgICBpZiAob3B0aW9ucy5wbGF5YmFja1JhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vbmNlTWVkaWFFdmVudCgnY2FucGxheScsICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wbGF5YmFja1JhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lZGlhLnBsYXliYWNrUmF0ZSA9IG9wdGlvbnMucGxheWJhY2tSYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uTWVkaWFFdmVudChldmVudCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tZWRpYS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgb25jZU1lZGlhRXZlbnQoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uTWVkaWFFdmVudChldmVudCwgY2FsbGJhY2ssIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgZ2V0U3JjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYS5jdXJyZW50U3JjIHx8IHRoaXMubWVkaWEuc3JjIHx8ICcnO1xuICAgIH1cbiAgICByZXZva2VTcmMoKSB7XG4gICAgICAgIGNvbnN0IHNyYyA9IHRoaXMuZ2V0U3JjKCk7XG4gICAgICAgIGlmIChzcmMuc3RhcnRzV2l0aCgnYmxvYjonKSkge1xuICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChzcmMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFNyYyh1cmwsIGJsb2IpIHtcbiAgICAgICAgY29uc3Qgc3JjID0gdGhpcy5nZXRTcmMoKTtcbiAgICAgICAgaWYgKHNyYyA9PT0gdXJsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJldm9rZVNyYygpO1xuICAgICAgICBjb25zdCBuZXdTcmMgPSBibG9iIGluc3RhbmNlb2YgQmxvYiA/IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYikgOiB1cmw7XG4gICAgICAgIHRoaXMubWVkaWEuc3JjID0gbmV3U3JjO1xuICAgICAgICB0aGlzLm1lZGlhLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5tZWRpYS5wYXVzZSgpO1xuICAgICAgICB0aGlzLnJldm9rZVNyYygpO1xuICAgICAgICB0aGlzLm1lZGlhLnNyYyA9ICcnO1xuICAgICAgICAvLyBMb2FkIHJlc2V0cyB0aGUgbWVkaWEgZWxlbWVudCB0byBpdHMgaW5pdGlhbCBzdGF0ZVxuICAgICAgICB0aGlzLm1lZGlhLmxvYWQoKTtcbiAgICB9XG4gICAgLyoqIFN0YXJ0IHBsYXlpbmcgdGhlIGF1ZGlvICovXG4gICAgcGxheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWEucGxheSgpO1xuICAgIH1cbiAgICAvKiogUGF1c2UgdGhlIGF1ZGlvICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHRoaXMubWVkaWEucGF1c2UoKTtcbiAgICB9XG4gICAgLyoqIENoZWNrIGlmIHRoZSBhdWRpbyBpcyBwbGF5aW5nICovXG4gICAgaXNQbGF5aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYS5jdXJyZW50VGltZSA+IDAgJiYgIXRoaXMubWVkaWEucGF1c2VkICYmICF0aGlzLm1lZGlhLmVuZGVkO1xuICAgIH1cbiAgICAvKiogSnVtcHQgdG8gYSBzcGVjaWZpYyB0aW1lIGluIHRoZSBhdWRpbyAoaW4gc2Vjb25kcykgKi9cbiAgICBzZXRUaW1lKHRpbWUpIHtcbiAgICAgICAgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA9IHRpbWU7XG4gICAgfVxuICAgIC8qKiBHZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBhdWRpbyBpbiBzZWNvbmRzICovXG4gICAgZ2V0RHVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhLmR1cmF0aW9uO1xuICAgIH1cbiAgICAvKiogR2V0IHRoZSBjdXJyZW50IGF1ZGlvIHBvc2l0aW9uIGluIHNlY29uZHMgKi9cbiAgICBnZXRDdXJyZW50VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWEuY3VycmVudFRpbWU7XG4gICAgfVxuICAgIC8qKiBHZXQgdGhlIGF1ZGlvIHZvbHVtZSAqL1xuICAgIGdldFZvbHVtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWEudm9sdW1lO1xuICAgIH1cbiAgICAvKiogU2V0IHRoZSBhdWRpbyB2b2x1bWUgKi9cbiAgICBzZXRWb2x1bWUodm9sdW1lKSB7XG4gICAgICAgIHRoaXMubWVkaWEudm9sdW1lID0gdm9sdW1lO1xuICAgIH1cbiAgICAvKiogR2V0IHRoZSBhdWRpbyBtdXRlZCBzdGF0ZSAqL1xuICAgIGdldE11dGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYS5tdXRlZDtcbiAgICB9XG4gICAgLyoqIE11dGUgb3IgdW5tdXRlIHRoZSBhdWRpbyAqL1xuICAgIHNldE11dGVkKG11dGVkKSB7XG4gICAgICAgIHRoaXMubWVkaWEubXV0ZWQgPSBtdXRlZDtcbiAgICB9XG4gICAgLyoqIEdldCB0aGUgcGxheWJhY2sgc3BlZWQgKi9cbiAgICBnZXRQbGF5YmFja1JhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhLnBsYXliYWNrUmF0ZTtcbiAgICB9XG4gICAgLyoqIFNldCB0aGUgcGxheWJhY2sgc3BlZWQsIHBhc3MgYW4gb3B0aW9uYWwgZmFsc2UgdG8gTk9UIHByZXNlcnZlIHRoZSBwaXRjaCAqL1xuICAgIHNldFBsYXliYWNrUmF0ZShyYXRlLCBwcmVzZXJ2ZVBpdGNoKSB7XG4gICAgICAgIC8vIHByZXNlcnZlUGl0Y2ggaXMgdHJ1ZSBieSBkZWZhdWx0IGluIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgaWYgKHByZXNlcnZlUGl0Y2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tZWRpYS5wcmVzZXJ2ZXNQaXRjaCA9IHByZXNlcnZlUGl0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWRpYS5wbGF5YmFja1JhdGUgPSByYXRlO1xuICAgIH1cbiAgICAvKiogR2V0IHRoZSBIVE1MIG1lZGlhIGVsZW1lbnQgKi9cbiAgICBnZXRNZWRpYUVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhO1xuICAgIH1cbiAgICAvKiogU2V0IGEgc2luayBpZCB0byBjaGFuZ2UgdGhlIGF1ZGlvIG91dHB1dCBkZXZpY2UgKi9cbiAgICBzZXRTaW5rSWQoc2lua0lkKSB7XG4gICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTE1lZGlhRWxlbWVudC9zZXRTaW5rSWRcbiAgICAgICAgY29uc3QgbWVkaWEgPSB0aGlzLm1lZGlhO1xuICAgICAgICByZXR1cm4gbWVkaWEuc2V0U2lua0lkKHNpbmtJZCk7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgUGxheWVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/wavesurfer.js/dist/player.js\n"));

/***/ }),

/***/ "./node_modules/wavesurfer.js/dist/renderer.js":
/*!*****************************************************!*\
  !*** ./node_modules/wavesurfer.js/dist/renderer.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _draggable_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draggable.js */ \"./node_modules/wavesurfer.js/dist/draggable.js\");\n/* harmony import */ var _event_emitter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./event-emitter.js */ \"./node_modules/wavesurfer.js/dist/event-emitter.js\");\n\n\nclass Renderer extends _event_emitter_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    constructor(options, audioElement) {\n        super();\n        this.timeouts = [];\n        this.isScrolling = false;\n        this.audioData = null;\n        this.resizeObserver = null;\n        this.isDragging = false;\n        this.options = options;\n        let parent;\n        if (typeof options.container === 'string') {\n            parent = document.querySelector(options.container);\n        }\n        else if (options.container instanceof HTMLElement) {\n            parent = options.container;\n        }\n        if (!parent) {\n            throw new Error('Container not found');\n        }\n        this.parent = parent;\n        const [div, shadow] = this.initHtml();\n        parent.appendChild(div);\n        this.container = div;\n        this.scrollContainer = shadow.querySelector('.scroll');\n        this.wrapper = shadow.querySelector('.wrapper');\n        this.canvasWrapper = shadow.querySelector('.canvases');\n        this.progressWrapper = shadow.querySelector('.progress');\n        this.cursor = shadow.querySelector('.cursor');\n        if (audioElement) {\n            shadow.appendChild(audioElement);\n        }\n        this.initEvents();\n    }\n    initEvents() {\n        // Add a click listener\n        this.wrapper.addEventListener('click', (e) => {\n            const rect = this.wrapper.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const relativeX = x / rect.width;\n            this.emit('click', relativeX);\n        });\n        // Drag\n        if (this.options.dragToSeek) {\n            this.initDrag();\n        }\n        // Add a scroll listener\n        this.scrollContainer.addEventListener('scroll', () => {\n            const { scrollLeft, scrollWidth, clientWidth } = this.scrollContainer;\n            const startX = scrollLeft / scrollWidth;\n            const endX = (scrollLeft + clientWidth) / scrollWidth;\n            this.emit('scroll', startX, endX);\n        });\n        // Re-render the waveform on container resize\n        const delay = this.createDelay(100);\n        this.resizeObserver = new ResizeObserver(() => {\n            delay(() => this.reRender());\n        });\n        this.resizeObserver.observe(this.scrollContainer);\n    }\n    initDrag() {\n        (0,_draggable_js__WEBPACK_IMPORTED_MODULE_0__.makeDraggable)(this.wrapper, \n        // On drag\n        (_, __, x) => {\n            this.emit('drag', Math.max(0, Math.min(1, x / this.wrapper.getBoundingClientRect().width)));\n        }, \n        // On start drag\n        () => (this.isDragging = true), \n        // On end drag\n        () => (this.isDragging = false));\n    }\n    getHeight() {\n        const defaultHeight = 128;\n        if (this.options.height == null)\n            return defaultHeight;\n        if (!isNaN(Number(this.options.height)))\n            return Number(this.options.height);\n        if (this.options.height === 'auto')\n            return this.parent.clientHeight || defaultHeight;\n        return defaultHeight;\n    }\n    initHtml() {\n        const div = document.createElement('div');\n        const shadow = div.attachShadow({ mode: 'open' });\n        shadow.innerHTML = `\n      <style>\n        :host {\n          user-select: none;\n        }\n        :host audio {\n          display: block;\n          width: 100%;\n        }\n        :host .scroll {\n          overflow-x: auto;\n          overflow-y: hidden;\n          width: 100%;\n          position: relative;\n          touch-action: none;\n        }\n        :host .noScrollbar {\n          scrollbar-color: transparent;\n          scrollbar-width: none;\n        }\n        :host .noScrollbar::-webkit-scrollbar {\n          display: none;\n          -webkit-appearance: none;\n        }\n        :host .wrapper {\n          position: relative;\n          overflow: visible;\n          z-index: 2;\n        }\n        :host .canvases {\n          min-height: ${this.getHeight()}px;\n        }\n        :host .canvases > div {\n          position: relative;\n        }\n        :host canvas {\n          display: block;\n          position: absolute;\n          top: 0;\n          image-rendering: pixelated;\n        }\n        :host .progress {\n          pointer-events: none;\n          position: absolute;\n          z-index: 2;\n          top: 0;\n          left: 0;\n          width: 0;\n          height: 100%;\n          overflow: hidden;\n        }\n        :host .progress > div {\n          position: relative;\n        }\n        :host .cursor {\n          pointer-events: none;\n          position: absolute;\n          z-index: 5;\n          top: 0;\n          left: 0;\n          height: 100%;\n          border-radius: 2px;\n        }\n      </style>\n\n      <div class=\"scroll\" part=\"scroll\">\n        <div class=\"wrapper\" part=\"wrapper\">\n          <div class=\"canvases\"></div>\n          <div class=\"progress\" part=\"progress\"></div>\n          <div class=\"cursor\" part=\"cursor\"></div>\n        </div>\n      </div>\n    `;\n        return [div, shadow];\n    }\n    setOptions(options) {\n        this.options = options;\n        // Re-render the waveform\n        this.reRender();\n    }\n    getWrapper() {\n        return this.wrapper;\n    }\n    getScroll() {\n        return this.scrollContainer.scrollLeft;\n    }\n    destroy() {\n        var _a;\n        this.container.remove();\n        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n    }\n    createDelay(delayMs = 10) {\n        const context = {};\n        this.timeouts.push(context);\n        return (callback) => {\n            context.timeout && clearTimeout(context.timeout);\n            context.timeout = setTimeout(callback, delayMs);\n        };\n    }\n    // Convert array of color values to linear gradient\n    convertColorValues(color) {\n        if (!Array.isArray(color))\n            return color || '';\n        if (color.length < 2)\n            return color[0] || '';\n        const canvasElement = document.createElement('canvas');\n        const ctx = canvasElement.getContext('2d');\n        const gradient = ctx.createLinearGradient(0, 0, 0, canvasElement.height);\n        const colorStopPercentage = 1 / (color.length - 1);\n        color.forEach((color, index) => {\n            const offset = index * colorStopPercentage;\n            gradient.addColorStop(offset, color);\n        });\n        return gradient;\n    }\n    renderBarWaveform(channelData, options, ctx, vScale) {\n        const topChannel = channelData[0];\n        const bottomChannel = channelData[1] || channelData[0];\n        const length = topChannel.length;\n        const { width, height } = ctx.canvas;\n        const halfHeight = height / 2;\n        const pixelRatio = window.devicePixelRatio || 1;\n        const barWidth = options.barWidth ? options.barWidth * pixelRatio : 1;\n        const barGap = options.barGap ? options.barGap * pixelRatio : options.barWidth ? barWidth / 2 : 0;\n        const barRadius = options.barRadius || 0;\n        const barIndexScale = width / (barWidth + barGap) / length;\n        const rectFn = barRadius && 'roundRect' in ctx ? 'roundRect' : 'rect';\n        ctx.beginPath();\n        let prevX = 0;\n        let maxTop = 0;\n        let maxBottom = 0;\n        for (let i = 0; i <= length; i++) {\n            const x = Math.round(i * barIndexScale);\n            if (x > prevX) {\n                const topBarHeight = Math.round(maxTop * halfHeight * vScale);\n                const bottomBarHeight = Math.round(maxBottom * halfHeight * vScale);\n                const barHeight = topBarHeight + bottomBarHeight || 1;\n                // Vertical alignment\n                let y = halfHeight - topBarHeight;\n                if (options.barAlign === 'top') {\n                    y = 0;\n                }\n                else if (options.barAlign === 'bottom') {\n                    y = height - barHeight;\n                }\n                ctx[rectFn](prevX * (barWidth + barGap), y, barWidth, barHeight, barRadius);\n                prevX = x;\n                maxTop = 0;\n                maxBottom = 0;\n            }\n            const magnitudeTop = Math.abs(topChannel[i] || 0);\n            const magnitudeBottom = Math.abs(bottomChannel[i] || 0);\n            if (magnitudeTop > maxTop)\n                maxTop = magnitudeTop;\n            if (magnitudeBottom > maxBottom)\n                maxBottom = magnitudeBottom;\n        }\n        ctx.fill();\n        ctx.closePath();\n    }\n    renderLineWaveform(channelData, _options, ctx, vScale) {\n        const drawChannel = (index) => {\n            const channel = channelData[index] || channelData[0];\n            const length = channel.length;\n            const { height } = ctx.canvas;\n            const halfHeight = height / 2;\n            const hScale = ctx.canvas.width / length;\n            ctx.moveTo(0, halfHeight);\n            let prevX = 0;\n            let max = 0;\n            for (let i = 0; i <= length; i++) {\n                const x = Math.round(i * hScale);\n                if (x > prevX) {\n                    const h = Math.round(max * halfHeight * vScale) || 1;\n                    const y = halfHeight + h * (index === 0 ? -1 : 1);\n                    ctx.lineTo(prevX, y);\n                    prevX = x;\n                    max = 0;\n                }\n                const value = Math.abs(channel[i] || 0);\n                if (value > max)\n                    max = value;\n            }\n            ctx.lineTo(prevX, halfHeight);\n        };\n        ctx.beginPath();\n        drawChannel(0);\n        drawChannel(1);\n        ctx.fill();\n        ctx.closePath();\n    }\n    renderWaveform(channelData, options, ctx) {\n        ctx.fillStyle = this.convertColorValues(options.waveColor);\n        // Custom rendering function\n        if (options.renderFunction) {\n            options.renderFunction(channelData, ctx);\n            return;\n        }\n        // Vertical scaling\n        let vScale = options.barHeight || 1;\n        if (options.normalize) {\n            const max = Array.from(channelData[0]).reduce((max, value) => Math.max(max, Math.abs(value)), 0);\n            vScale = max ? 1 / max : 1;\n        }\n        // Render waveform as bars\n        if (options.barWidth || options.barGap || options.barAlign) {\n            this.renderBarWaveform(channelData, options, ctx, vScale);\n            return;\n        }\n        // Render waveform as a polyline\n        this.renderLineWaveform(channelData, options, ctx, vScale);\n    }\n    renderSingleCanvas(channelData, options, width, height, start, end, canvasContainer, progressContainer) {\n        const pixelRatio = window.devicePixelRatio || 1;\n        const canvas = document.createElement('canvas');\n        const length = channelData[0].length;\n        canvas.width = Math.round((width * (end - start)) / length);\n        canvas.height = height * pixelRatio;\n        canvas.style.width = `${Math.floor(canvas.width / pixelRatio)}px`;\n        canvas.style.height = `${height}px`;\n        canvas.style.left = `${Math.floor((start * width) / pixelRatio / length)}px`;\n        canvasContainer.appendChild(canvas);\n        const ctx = canvas.getContext('2d');\n        this.renderWaveform(channelData.map((channel) => channel.slice(start, end)), options, ctx);\n        // Draw a progress canvas\n        const progressCanvas = canvas.cloneNode();\n        progressContainer.appendChild(progressCanvas);\n        const progressCtx = progressCanvas.getContext('2d');\n        if (canvas.width > 0 && canvas.height > 0) {\n            progressCtx.drawImage(canvas, 0, 0);\n        }\n        // Set the composition method to draw only where the waveform is drawn\n        progressCtx.globalCompositeOperation = 'source-in';\n        progressCtx.fillStyle = this.convertColorValues(options.progressColor);\n        // This rectangle acts as a mask thanks to the composition method\n        progressCtx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    renderChannel(channelData, options, width) {\n        // A container for canvases\n        const canvasContainer = document.createElement('div');\n        const height = this.getHeight();\n        canvasContainer.style.height = `${height}px`;\n        this.canvasWrapper.style.minHeight = `${height}px`;\n        this.canvasWrapper.appendChild(canvasContainer);\n        // A container for progress canvases\n        const progressContainer = canvasContainer.cloneNode();\n        this.progressWrapper.appendChild(progressContainer);\n        // Determine the currently visible part of the waveform\n        const { scrollLeft, scrollWidth, clientWidth } = this.scrollContainer;\n        const len = channelData[0].length;\n        const scale = len / scrollWidth;\n        let viewportWidth = Math.min(Renderer.MAX_CANVAS_WIDTH, clientWidth);\n        // Adjust width to avoid gaps between canvases when using bars\n        if (options.barWidth || options.barGap) {\n            const barWidth = options.barWidth || 0.5;\n            const barGap = options.barGap || barWidth / 2;\n            const totalBarWidth = barWidth + barGap;\n            if (viewportWidth % totalBarWidth !== 0) {\n                viewportWidth = Math.floor(viewportWidth / totalBarWidth) * totalBarWidth;\n            }\n        }\n        const start = Math.floor(Math.abs(scrollLeft) * scale);\n        const end = Math.floor(start + viewportWidth * scale);\n        const viewportLen = end - start;\n        // Draw a portion of the waveform from start peak to end peak\n        const draw = (start, end) => {\n            this.renderSingleCanvas(channelData, options, width, height, Math.max(0, start), Math.min(end, len), canvasContainer, progressContainer);\n        };\n        // Draw the waveform in viewport chunks, each with a delay\n        const headDelay = this.createDelay();\n        const tailDelay = this.createDelay();\n        const renderHead = (fromIndex, toIndex) => {\n            draw(fromIndex, toIndex);\n            if (fromIndex > 0) {\n                headDelay(() => {\n                    renderHead(fromIndex - viewportLen, toIndex - viewportLen);\n                });\n            }\n        };\n        const renderTail = (fromIndex, toIndex) => {\n            draw(fromIndex, toIndex);\n            if (toIndex < len) {\n                tailDelay(() => {\n                    renderTail(fromIndex + viewportLen, toIndex + viewportLen);\n                });\n            }\n        };\n        renderHead(start, end);\n        if (end < len) {\n            renderTail(end, end + viewportLen);\n        }\n    }\n    render(audioData) {\n        // Clear previous timeouts\n        this.timeouts.forEach((context) => context.timeout && clearTimeout(context.timeout));\n        this.timeouts = [];\n        // Clear the canvases\n        this.canvasWrapper.innerHTML = '';\n        this.progressWrapper.innerHTML = '';\n        this.wrapper.style.width = '';\n        // Determine the width of the waveform\n        const pixelRatio = window.devicePixelRatio || 1;\n        const parentWidth = this.scrollContainer.clientWidth;\n        const scrollWidth = Math.ceil(audioData.duration * (this.options.minPxPerSec || 0));\n        // Whether the container should scroll\n        this.isScrolling = scrollWidth > parentWidth;\n        const useParentWidth = this.options.fillParent && !this.isScrolling;\n        // Width of the waveform in pixels\n        const width = (useParentWidth ? parentWidth : scrollWidth) * pixelRatio;\n        // Set the width of the wrapper\n        this.wrapper.style.width = useParentWidth ? '100%' : `${scrollWidth}px`;\n        // Set additional styles\n        this.scrollContainer.style.overflowX = this.isScrolling ? 'auto' : 'hidden';\n        this.scrollContainer.classList.toggle('noScrollbar', !!this.options.hideScrollbar);\n        this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`;\n        this.cursor.style.width = `${this.options.cursorWidth}px`;\n        // Render the waveform\n        if (this.options.splitChannels) {\n            // Render a waveform for each channel\n            for (let i = 0; i < audioData.numberOfChannels; i++) {\n                const options = Object.assign(Object.assign({}, this.options), this.options.splitChannels[i]);\n                this.renderChannel([audioData.getChannelData(i)], options, width);\n            }\n        }\n        else {\n            // Render a single waveform for the first two channels (left and right)\n            const channels = [audioData.getChannelData(0)];\n            if (audioData.numberOfChannels > 1)\n                channels.push(audioData.getChannelData(1));\n            this.renderChannel(channels, this.options, width);\n        }\n        this.audioData = audioData;\n        this.emit('render');\n    }\n    reRender() {\n        // Return if the waveform has not been rendered yet\n        if (!this.audioData)\n            return;\n        // Remember the current cursor position\n        const oldCursorPosition = this.progressWrapper.clientWidth;\n        // Set the new zoom level and re-render the waveform\n        this.render(this.audioData);\n        // Adjust the scroll position so that the cursor stays in the same place\n        const newCursortPosition = this.progressWrapper.clientWidth;\n        this.scrollContainer.scrollLeft += newCursortPosition - oldCursorPosition;\n    }\n    zoom(minPxPerSec) {\n        this.options.minPxPerSec = minPxPerSec;\n        this.reRender();\n    }\n    scrollIntoView(progress, isPlaying = false) {\n        const { clientWidth, scrollLeft, scrollWidth } = this.scrollContainer;\n        const progressWidth = scrollWidth * progress;\n        const center = clientWidth / 2;\n        const minScroll = isPlaying && this.options.autoCenter && !this.isDragging ? center : clientWidth;\n        if (progressWidth > scrollLeft + minScroll || progressWidth < scrollLeft) {\n            // Scroll to the center\n            if (this.options.autoCenter && !this.isDragging) {\n                // If the cursor is in viewport but not centered, scroll to the center slowly\n                const minDiff = center / 20;\n                if (progressWidth - (scrollLeft + center) >= minDiff && progressWidth < scrollLeft + clientWidth) {\n                    this.scrollContainer.scrollLeft += minDiff;\n                }\n                else {\n                    // Otherwise, scroll to the center immediately\n                    this.scrollContainer.scrollLeft = progressWidth - center;\n                }\n            }\n            else if (this.isDragging) {\n                // Scroll just a little bit to allow for some space between the cursor and the edge\n                const gap = 10;\n                this.scrollContainer.scrollLeft =\n                    progressWidth < scrollLeft ? progressWidth - gap : progressWidth - clientWidth + gap;\n            }\n            else {\n                // Scroll to the beginning\n                this.scrollContainer.scrollLeft = progressWidth;\n            }\n        }\n        // Emit the scroll event\n        {\n            const { scrollLeft } = this.scrollContainer;\n            const startX = scrollLeft / scrollWidth;\n            const endX = (scrollLeft + clientWidth) / scrollWidth;\n            this.emit('scroll', startX, endX);\n        }\n    }\n    renderProgress(progress, isPlaying) {\n        if (isNaN(progress))\n            return;\n        this.progressWrapper.style.width = `${progress * 100}%`;\n        this.cursor.style.left = `${progress * 100}%`;\n        this.cursor.style.marginLeft = Math.round(progress * 100) === 100 ? `-${this.options.cursorWidth}px` : '';\n        if (this.isScrolling && this.options.autoScroll) {\n            this.scrollIntoView(progress, isPlaying);\n        }\n    }\n}\nRenderer.MAX_CANVAS_WIDTH = 4000;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Renderer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3JlbmRlcmVyLmpzIiwibWFwcGluZ3MiOiI7OztBQUErQztBQUNEO0FBQzlDLHVCQUF1Qix5REFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVDQUF1QztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHNDQUFzQztBQUN0RSxpQ0FBaUMsT0FBTztBQUN4QywrQkFBK0Isa0RBQWtEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRCxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsWUFBWTtBQUM1RTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsdURBQXVEO0FBQ3RHLHFDQUFxQyx5QkFBeUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdDQUFnQztBQUM1RCw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxlQUFlO0FBQzdELG9DQUFvQyxlQUFlO0FBQ25ELGdGQUFnRix5QkFBeUI7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy93YXZlc3VyZmVyLmpzL2Rpc3QvcmVuZGVyZXIuanM/NDQzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYWtlRHJhZ2dhYmxlIH0gZnJvbSAnLi9kcmFnZ2FibGUuanMnO1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICcuL2V2ZW50LWVtaXR0ZXIuanMnO1xuY2xhc3MgUmVuZGVyZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGF1ZGlvRWxlbWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRpbWVvdXRzID0gW107XG4gICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdWRpb0RhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBwYXJlbnQ7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb250YWluZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdGlvbnMuY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBvcHRpb25zLmNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250YWluZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGNvbnN0IFtkaXYsIHNoYWRvd10gPSB0aGlzLmluaXRIdG1sKCk7XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGRpdjtcbiAgICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIgPSBzaGFkb3cucXVlcnlTZWxlY3RvcignLnNjcm9sbCcpO1xuICAgICAgICB0aGlzLndyYXBwZXIgPSBzaGFkb3cucXVlcnlTZWxlY3RvcignLndyYXBwZXInKTtcbiAgICAgICAgdGhpcy5jYW52YXNXcmFwcGVyID0gc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXNlcycpO1xuICAgICAgICB0aGlzLnByb2dyZXNzV3JhcHBlciA9IHNoYWRvdy5xdWVyeVNlbGVjdG9yKCcucHJvZ3Jlc3MnKTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBzaGFkb3cucXVlcnlTZWxlY3RvcignLmN1cnNvcicpO1xuICAgICAgICBpZiAoYXVkaW9FbGVtZW50KSB7XG4gICAgICAgICAgICBzaGFkb3cuYXBwZW5kQ2hpbGQoYXVkaW9FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRFdmVudHMoKTtcbiAgICB9XG4gICAgaW5pdEV2ZW50cygpIHtcbiAgICAgICAgLy8gQWRkIGEgY2xpY2sgbGlzdGVuZXJcbiAgICAgICAgdGhpcy53cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCB4ID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVYID0geCAvIHJlY3Qud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NsaWNrJywgcmVsYXRpdmVYKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERyYWdcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcmFnVG9TZWVrKSB7XG4gICAgICAgICAgICB0aGlzLmluaXREcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGEgc2Nyb2xsIGxpc3RlbmVyXG4gICAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsTGVmdCwgc2Nyb2xsV2lkdGgsIGNsaWVudFdpZHRoIH0gPSB0aGlzLnNjcm9sbENvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0WCA9IHNjcm9sbExlZnQgLyBzY3JvbGxXaWR0aDtcbiAgICAgICAgICAgIGNvbnN0IGVuZFggPSAoc2Nyb2xsTGVmdCArIGNsaWVudFdpZHRoKSAvIHNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzY3JvbGwnLCBzdGFydFgsIGVuZFgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmUtcmVuZGVyIHRoZSB3YXZlZm9ybSBvbiBjb250YWluZXIgcmVzaXplXG4gICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5jcmVhdGVEZWxheSgxMDApO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgIGRlbGF5KCgpID0+IHRoaXMucmVSZW5kZXIoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5zY3JvbGxDb250YWluZXIpO1xuICAgIH1cbiAgICBpbml0RHJhZygpIHtcbiAgICAgICAgbWFrZURyYWdnYWJsZSh0aGlzLndyYXBwZXIsIFxuICAgICAgICAvLyBPbiBkcmFnXG4gICAgICAgIChfLCBfXywgeCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkcmFnJywgTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgeCAvIHRoaXMud3JhcHBlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkpKTtcbiAgICAgICAgfSwgXG4gICAgICAgIC8vIE9uIHN0YXJ0IGRyYWdcbiAgICAgICAgKCkgPT4gKHRoaXMuaXNEcmFnZ2luZyA9IHRydWUpLCBcbiAgICAgICAgLy8gT24gZW5kIGRyYWdcbiAgICAgICAgKCkgPT4gKHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlKSk7XG4gICAgfVxuICAgIGdldEhlaWdodCgpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdEhlaWdodCA9IDEyODtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWlnaHQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0SGVpZ2h0O1xuICAgICAgICBpZiAoIWlzTmFOKE51bWJlcih0aGlzLm9wdGlvbnMuaGVpZ2h0KSkpXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMub3B0aW9ucy5oZWlnaHQpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNsaWVudEhlaWdodCB8fCBkZWZhdWx0SGVpZ2h0O1xuICAgICAgICByZXR1cm4gZGVmYXVsdEhlaWdodDtcbiAgICB9XG4gICAgaW5pdEh0bWwoKSB7XG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCBzaGFkb3cgPSBkaXYuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgICAgICBzaGFkb3cuaW5uZXJIVE1MID0gYFxuICAgICAgPHN0eWxlPlxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QgYXVkaW8ge1xuICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICB9XG4gICAgICAgIDpob3N0IC5zY3JvbGwge1xuICAgICAgICAgIG92ZXJmbG93LXg6IGF1dG87XG4gICAgICAgICAgb3ZlcmZsb3cteTogaGlkZGVuO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICB0b3VjaC1hY3Rpb246IG5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QgLm5vU2Nyb2xsYmFyIHtcbiAgICAgICAgICBzY3JvbGxiYXItY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICAgIHNjcm9sbGJhci13aWR0aDogbm9uZTtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdCAubm9TY3JvbGxiYXI6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbiAgICAgICAgfVxuICAgICAgICA6aG9zdCAud3JhcHBlciB7XG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICAgICAgICAgIHotaW5kZXg6IDI7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QgLmNhbnZhc2VzIHtcbiAgICAgICAgICBtaW4taGVpZ2h0OiAke3RoaXMuZ2V0SGVpZ2h0KCl9cHg7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QgLmNhbnZhc2VzID4gZGl2IHtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QgY2FudmFzIHtcbiAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgdG9wOiAwO1xuICAgICAgICAgIGltYWdlLXJlbmRlcmluZzogcGl4ZWxhdGVkO1xuICAgICAgICB9XG4gICAgICAgIDpob3N0IC5wcm9ncmVzcyB7XG4gICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgIHotaW5kZXg6IDI7XG4gICAgICAgICAgdG9wOiAwO1xuICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgd2lkdGg6IDA7XG4gICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QgLnByb2dyZXNzID4gZGl2IHtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QgLmN1cnNvciB7XG4gICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICAgIHotaW5kZXg6IDU7XG4gICAgICAgICAgdG9wOiAwO1xuICAgICAgICAgIGxlZnQ6IDA7XG4gICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgfVxuICAgICAgPC9zdHlsZT5cblxuICAgICAgPGRpdiBjbGFzcz1cInNjcm9sbFwiIHBhcnQ9XCJzY3JvbGxcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIndyYXBwZXJcIiBwYXJ0PVwid3JhcHBlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjYW52YXNlc1wiPjwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzc1wiIHBhcnQ9XCJwcm9ncmVzc1wiPjwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJjdXJzb3JcIiBwYXJ0PVwiY3Vyc29yXCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgYDtcbiAgICAgICAgcmV0dXJuIFtkaXYsIHNoYWRvd107XG4gICAgfVxuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAvLyBSZS1yZW5kZXIgdGhlIHdhdmVmb3JtXG4gICAgICAgIHRoaXMucmVSZW5kZXIoKTtcbiAgICB9XG4gICAgZ2V0V3JhcHBlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcHBlcjtcbiAgICB9XG4gICAgZ2V0U2Nyb2xsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgKF9hID0gdGhpcy5yZXNpemVPYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgY3JlYXRlRGVsYXkoZGVsYXlNcyA9IDEwKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7fTtcbiAgICAgICAgdGhpcy50aW1lb3V0cy5wdXNoKGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjb250ZXh0LnRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KGNvbnRleHQudGltZW91dCk7XG4gICAgICAgICAgICBjb250ZXh0LnRpbWVvdXQgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheU1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ29udmVydCBhcnJheSBvZiBjb2xvciB2YWx1ZXMgdG8gbGluZWFyIGdyYWRpZW50XG4gICAgY29udmVydENvbG9yVmFsdWVzKGNvbG9yKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb2xvcikpXG4gICAgICAgICAgICByZXR1cm4gY29sb3IgfHwgJyc7XG4gICAgICAgIGlmIChjb2xvci5sZW5ndGggPCAyKVxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yWzBdIHx8ICcnO1xuICAgICAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29uc3QgZ3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgMCwgY2FudmFzRWxlbWVudC5oZWlnaHQpO1xuICAgICAgICBjb25zdCBjb2xvclN0b3BQZXJjZW50YWdlID0gMSAvIChjb2xvci5sZW5ndGggLSAxKTtcbiAgICAgICAgY29sb3IuZm9yRWFjaCgoY29sb3IsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAqIGNvbG9yU3RvcFBlcmNlbnRhZ2U7XG4gICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aob2Zmc2V0LCBjb2xvcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZ3JhZGllbnQ7XG4gICAgfVxuICAgIHJlbmRlckJhcldhdmVmb3JtKGNoYW5uZWxEYXRhLCBvcHRpb25zLCBjdHgsIHZTY2FsZSkge1xuICAgICAgICBjb25zdCB0b3BDaGFubmVsID0gY2hhbm5lbERhdGFbMF07XG4gICAgICAgIGNvbnN0IGJvdHRvbUNoYW5uZWwgPSBjaGFubmVsRGF0YVsxXSB8fCBjaGFubmVsRGF0YVswXTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdG9wQ2hhbm5lbC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY3R4LmNhbnZhcztcbiAgICAgICAgY29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICBjb25zdCBiYXJXaWR0aCA9IG9wdGlvbnMuYmFyV2lkdGggPyBvcHRpb25zLmJhcldpZHRoICogcGl4ZWxSYXRpbyA6IDE7XG4gICAgICAgIGNvbnN0IGJhckdhcCA9IG9wdGlvbnMuYmFyR2FwID8gb3B0aW9ucy5iYXJHYXAgKiBwaXhlbFJhdGlvIDogb3B0aW9ucy5iYXJXaWR0aCA/IGJhcldpZHRoIC8gMiA6IDA7XG4gICAgICAgIGNvbnN0IGJhclJhZGl1cyA9IG9wdGlvbnMuYmFyUmFkaXVzIHx8IDA7XG4gICAgICAgIGNvbnN0IGJhckluZGV4U2NhbGUgPSB3aWR0aCAvIChiYXJXaWR0aCArIGJhckdhcCkgLyBsZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlY3RGbiA9IGJhclJhZGl1cyAmJiAncm91bmRSZWN0JyBpbiBjdHggPyAncm91bmRSZWN0JyA6ICdyZWN0JztcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBsZXQgcHJldlggPSAwO1xuICAgICAgICBsZXQgbWF4VG9wID0gMDtcbiAgICAgICAgbGV0IG1heEJvdHRvbSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5yb3VuZChpICogYmFySW5kZXhTY2FsZSk7XG4gICAgICAgICAgICBpZiAoeCA+IHByZXZYKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9wQmFySGVpZ2h0ID0gTWF0aC5yb3VuZChtYXhUb3AgKiBoYWxmSGVpZ2h0ICogdlNjYWxlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBib3R0b21CYXJIZWlnaHQgPSBNYXRoLnJvdW5kKG1heEJvdHRvbSAqIGhhbGZIZWlnaHQgKiB2U2NhbGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhckhlaWdodCA9IHRvcEJhckhlaWdodCArIGJvdHRvbUJhckhlaWdodCB8fCAxO1xuICAgICAgICAgICAgICAgIC8vIFZlcnRpY2FsIGFsaWdubWVudFxuICAgICAgICAgICAgICAgIGxldCB5ID0gaGFsZkhlaWdodCAtIHRvcEJhckhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5iYXJBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYmFyQWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBoZWlnaHQgLSBiYXJIZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eFtyZWN0Rm5dKHByZXZYICogKGJhcldpZHRoICsgYmFyR2FwKSwgeSwgYmFyV2lkdGgsIGJhckhlaWdodCwgYmFyUmFkaXVzKTtcbiAgICAgICAgICAgICAgICBwcmV2WCA9IHg7XG4gICAgICAgICAgICAgICAgbWF4VG9wID0gMDtcbiAgICAgICAgICAgICAgICBtYXhCb3R0b20gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWFnbml0dWRlVG9wID0gTWF0aC5hYnModG9wQ2hhbm5lbFtpXSB8fCAwKTtcbiAgICAgICAgICAgIGNvbnN0IG1hZ25pdHVkZUJvdHRvbSA9IE1hdGguYWJzKGJvdHRvbUNoYW5uZWxbaV0gfHwgMCk7XG4gICAgICAgICAgICBpZiAobWFnbml0dWRlVG9wID4gbWF4VG9wKVxuICAgICAgICAgICAgICAgIG1heFRvcCA9IG1hZ25pdHVkZVRvcDtcbiAgICAgICAgICAgIGlmIChtYWduaXR1ZGVCb3R0b20gPiBtYXhCb3R0b20pXG4gICAgICAgICAgICAgICAgbWF4Qm90dG9tID0gbWFnbml0dWRlQm90dG9tO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgcmVuZGVyTGluZVdhdmVmb3JtKGNoYW5uZWxEYXRhLCBfb3B0aW9ucywgY3R4LCB2U2NhbGUpIHtcbiAgICAgICAgY29uc3QgZHJhd0NoYW5uZWwgPSAoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSBjaGFubmVsRGF0YVtpbmRleF0gfHwgY2hhbm5lbERhdGFbMF07XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjaGFubmVsLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHsgaGVpZ2h0IH0gPSBjdHguY2FudmFzO1xuICAgICAgICAgICAgY29uc3QgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XG4gICAgICAgICAgICBjb25zdCBoU2NhbGUgPSBjdHguY2FudmFzLndpZHRoIC8gbGVuZ3RoO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbygwLCBoYWxmSGVpZ2h0KTtcbiAgICAgICAgICAgIGxldCBwcmV2WCA9IDA7XG4gICAgICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgucm91bmQoaSAqIGhTY2FsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHggPiBwcmV2WCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoID0gTWF0aC5yb3VuZChtYXggKiBoYWxmSGVpZ2h0ICogdlNjYWxlKSB8fCAxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5ID0gaGFsZkhlaWdodCArIGggKiAoaW5kZXggPT09IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgICAgICAgICBjdHgubGluZVRvKHByZXZYLCB5KTtcbiAgICAgICAgICAgICAgICAgICAgcHJldlggPSB4O1xuICAgICAgICAgICAgICAgICAgICBtYXggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IE1hdGguYWJzKGNoYW5uZWxbaV0gfHwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID4gbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5saW5lVG8ocHJldlgsIGhhbGZIZWlnaHQpO1xuICAgICAgICB9O1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGRyYXdDaGFubmVsKDApO1xuICAgICAgICBkcmF3Q2hhbm5lbCgxKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICByZW5kZXJXYXZlZm9ybShjaGFubmVsRGF0YSwgb3B0aW9ucywgY3R4KSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmNvbnZlcnRDb2xvclZhbHVlcyhvcHRpb25zLndhdmVDb2xvcik7XG4gICAgICAgIC8vIEN1c3RvbSByZW5kZXJpbmcgZnVuY3Rpb25cbiAgICAgICAgaWYgKG9wdGlvbnMucmVuZGVyRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIG9wdGlvbnMucmVuZGVyRnVuY3Rpb24oY2hhbm5lbERhdGEsIGN0eCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmVydGljYWwgc2NhbGluZ1xuICAgICAgICBsZXQgdlNjYWxlID0gb3B0aW9ucy5iYXJIZWlnaHQgfHwgMTtcbiAgICAgICAgaWYgKG9wdGlvbnMubm9ybWFsaXplKSB7XG4gICAgICAgICAgICBjb25zdCBtYXggPSBBcnJheS5mcm9tKGNoYW5uZWxEYXRhWzBdKS5yZWR1Y2UoKG1heCwgdmFsdWUpID0+IE1hdGgubWF4KG1heCwgTWF0aC5hYnModmFsdWUpKSwgMCk7XG4gICAgICAgICAgICB2U2NhbGUgPSBtYXggPyAxIC8gbWF4IDogMTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5kZXIgd2F2ZWZvcm0gYXMgYmFyc1xuICAgICAgICBpZiAob3B0aW9ucy5iYXJXaWR0aCB8fCBvcHRpb25zLmJhckdhcCB8fCBvcHRpb25zLmJhckFsaWduKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckJhcldhdmVmb3JtKGNoYW5uZWxEYXRhLCBvcHRpb25zLCBjdHgsIHZTY2FsZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZGVyIHdhdmVmb3JtIGFzIGEgcG9seWxpbmVcbiAgICAgICAgdGhpcy5yZW5kZXJMaW5lV2F2ZWZvcm0oY2hhbm5lbERhdGEsIG9wdGlvbnMsIGN0eCwgdlNjYWxlKTtcbiAgICB9XG4gICAgcmVuZGVyU2luZ2xlQ2FudmFzKGNoYW5uZWxEYXRhLCBvcHRpb25zLCB3aWR0aCwgaGVpZ2h0LCBzdGFydCwgZW5kLCBjYW52YXNDb250YWluZXIsIHByb2dyZXNzQ29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gY2hhbm5lbERhdGFbMF0ubGVuZ3RoO1xuICAgICAgICBjYW52YXMud2lkdGggPSBNYXRoLnJvdW5kKCh3aWR0aCAqIChlbmQgLSBzdGFydCkpIC8gbGVuZ3RoKTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke01hdGguZmxvb3IoY2FudmFzLndpZHRoIC8gcGl4ZWxSYXRpbyl9cHhgO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcbiAgICAgICAgY2FudmFzLnN0eWxlLmxlZnQgPSBgJHtNYXRoLmZsb29yKChzdGFydCAqIHdpZHRoKSAvIHBpeGVsUmF0aW8gLyBsZW5ndGgpfXB4YDtcbiAgICAgICAgY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB0aGlzLnJlbmRlcldhdmVmb3JtKGNoYW5uZWxEYXRhLm1hcCgoY2hhbm5lbCkgPT4gY2hhbm5lbC5zbGljZShzdGFydCwgZW5kKSksIG9wdGlvbnMsIGN0eCk7XG4gICAgICAgIC8vIERyYXcgYSBwcm9ncmVzcyBjYW52YXNcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NDYW52YXMgPSBjYW52YXMuY2xvbmVOb2RlKCk7XG4gICAgICAgIHByb2dyZXNzQ29udGFpbmVyLmFwcGVuZENoaWxkKHByb2dyZXNzQ2FudmFzKTtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NDdHggPSBwcm9ncmVzc0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoY2FudmFzLndpZHRoID4gMCAmJiBjYW52YXMuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgcHJvZ3Jlc3NDdHguZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSBjb21wb3NpdGlvbiBtZXRob2QgdG8gZHJhdyBvbmx5IHdoZXJlIHRoZSB3YXZlZm9ybSBpcyBkcmF3blxuICAgICAgICBwcm9ncmVzc0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLWluJztcbiAgICAgICAgcHJvZ3Jlc3NDdHguZmlsbFN0eWxlID0gdGhpcy5jb252ZXJ0Q29sb3JWYWx1ZXMob3B0aW9ucy5wcm9ncmVzc0NvbG9yKTtcbiAgICAgICAgLy8gVGhpcyByZWN0YW5nbGUgYWN0cyBhcyBhIG1hc2sgdGhhbmtzIHRvIHRoZSBjb21wb3NpdGlvbiBtZXRob2RcbiAgICAgICAgcHJvZ3Jlc3NDdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB9XG4gICAgcmVuZGVyQ2hhbm5lbChjaGFubmVsRGF0YSwgb3B0aW9ucywgd2lkdGgpIHtcbiAgICAgICAgLy8gQSBjb250YWluZXIgZm9yIGNhbnZhc2VzXG4gICAgICAgIGNvbnN0IGNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgICAgICBjYW52YXNDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcbiAgICAgICAgdGhpcy5jYW52YXNXcmFwcGVyLnN0eWxlLm1pbkhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gICAgICAgIHRoaXMuY2FudmFzV3JhcHBlci5hcHBlbmRDaGlsZChjYW52YXNDb250YWluZXIpO1xuICAgICAgICAvLyBBIGNvbnRhaW5lciBmb3IgcHJvZ3Jlc3MgY2FudmFzZXNcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NDb250YWluZXIgPSBjYW52YXNDb250YWluZXIuY2xvbmVOb2RlKCk7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NXcmFwcGVyLmFwcGVuZENoaWxkKHByb2dyZXNzQ29udGFpbmVyKTtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBjdXJyZW50bHkgdmlzaWJsZSBwYXJ0IG9mIHRoZSB3YXZlZm9ybVxuICAgICAgICBjb25zdCB7IHNjcm9sbExlZnQsIHNjcm9sbFdpZHRoLCBjbGllbnRXaWR0aCB9ID0gdGhpcy5zY3JvbGxDb250YWluZXI7XG4gICAgICAgIGNvbnN0IGxlbiA9IGNoYW5uZWxEYXRhWzBdLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBsZW4gLyBzY3JvbGxXaWR0aDtcbiAgICAgICAgbGV0IHZpZXdwb3J0V2lkdGggPSBNYXRoLm1pbihSZW5kZXJlci5NQVhfQ0FOVkFTX1dJRFRILCBjbGllbnRXaWR0aCk7XG4gICAgICAgIC8vIEFkanVzdCB3aWR0aCB0byBhdm9pZCBnYXBzIGJldHdlZW4gY2FudmFzZXMgd2hlbiB1c2luZyBiYXJzXG4gICAgICAgIGlmIChvcHRpb25zLmJhcldpZHRoIHx8IG9wdGlvbnMuYmFyR2FwKSB7XG4gICAgICAgICAgICBjb25zdCBiYXJXaWR0aCA9IG9wdGlvbnMuYmFyV2lkdGggfHwgMC41O1xuICAgICAgICAgICAgY29uc3QgYmFyR2FwID0gb3B0aW9ucy5iYXJHYXAgfHwgYmFyV2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3QgdG90YWxCYXJXaWR0aCA9IGJhcldpZHRoICsgYmFyR2FwO1xuICAgICAgICAgICAgaWYgKHZpZXdwb3J0V2lkdGggJSB0b3RhbEJhcldpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmlld3BvcnRXaWR0aCA9IE1hdGguZmxvb3Iodmlld3BvcnRXaWR0aCAvIHRvdGFsQmFyV2lkdGgpICogdG90YWxCYXJXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGguZmxvb3IoTWF0aC5hYnMoc2Nyb2xsTGVmdCkgKiBzY2FsZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IE1hdGguZmxvb3Ioc3RhcnQgKyB2aWV3cG9ydFdpZHRoICogc2NhbGUpO1xuICAgICAgICBjb25zdCB2aWV3cG9ydExlbiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICAvLyBEcmF3IGEgcG9ydGlvbiBvZiB0aGUgd2F2ZWZvcm0gZnJvbSBzdGFydCBwZWFrIHRvIGVuZCBwZWFrXG4gICAgICAgIGNvbnN0IGRyYXcgPSAoc3RhcnQsIGVuZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJTaW5nbGVDYW52YXMoY2hhbm5lbERhdGEsIG9wdGlvbnMsIHdpZHRoLCBoZWlnaHQsIE1hdGgubWF4KDAsIHN0YXJ0KSwgTWF0aC5taW4oZW5kLCBsZW4pLCBjYW52YXNDb250YWluZXIsIHByb2dyZXNzQ29udGFpbmVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRHJhdyB0aGUgd2F2ZWZvcm0gaW4gdmlld3BvcnQgY2h1bmtzLCBlYWNoIHdpdGggYSBkZWxheVxuICAgICAgICBjb25zdCBoZWFkRGVsYXkgPSB0aGlzLmNyZWF0ZURlbGF5KCk7XG4gICAgICAgIGNvbnN0IHRhaWxEZWxheSA9IHRoaXMuY3JlYXRlRGVsYXkoKTtcbiAgICAgICAgY29uc3QgcmVuZGVySGVhZCA9IChmcm9tSW5kZXgsIHRvSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGRyYXcoZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICAgICAgICAgIGlmIChmcm9tSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgaGVhZERlbGF5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVySGVhZChmcm9tSW5kZXggLSB2aWV3cG9ydExlbiwgdG9JbmRleCAtIHZpZXdwb3J0TGVuKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVuZGVyVGFpbCA9IChmcm9tSW5kZXgsIHRvSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGRyYXcoZnJvbUluZGV4LCB0b0luZGV4KTtcbiAgICAgICAgICAgIGlmICh0b0luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdGFpbERlbGF5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGFpbChmcm9tSW5kZXggKyB2aWV3cG9ydExlbiwgdG9JbmRleCArIHZpZXdwb3J0TGVuKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmVuZGVySGVhZChzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGVuZCA8IGxlbikge1xuICAgICAgICAgICAgcmVuZGVyVGFpbChlbmQsIGVuZCArIHZpZXdwb3J0TGVuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXIoYXVkaW9EYXRhKSB7XG4gICAgICAgIC8vIENsZWFyIHByZXZpb3VzIHRpbWVvdXRzXG4gICAgICAgIHRoaXMudGltZW91dHMuZm9yRWFjaCgoY29udGV4dCkgPT4gY29udGV4dC50aW1lb3V0ICYmIGNsZWFyVGltZW91dChjb250ZXh0LnRpbWVvdXQpKTtcbiAgICAgICAgdGhpcy50aW1lb3V0cyA9IFtdO1xuICAgICAgICAvLyBDbGVhciB0aGUgY2FudmFzZXNcbiAgICAgICAgdGhpcy5jYW52YXNXcmFwcGVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0aGlzLnByb2dyZXNzV3JhcHBlci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLndpZHRoID0gJyc7XG4gICAgICAgIC8vIERldGVybWluZSB0aGUgd2lkdGggb2YgdGhlIHdhdmVmb3JtXG4gICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgICBjb25zdCBwYXJlbnRXaWR0aCA9IHRoaXMuc2Nyb2xsQ29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgICBjb25zdCBzY3JvbGxXaWR0aCA9IE1hdGguY2VpbChhdWRpb0RhdGEuZHVyYXRpb24gKiAodGhpcy5vcHRpb25zLm1pblB4UGVyU2VjIHx8IDApKTtcbiAgICAgICAgLy8gV2hldGhlciB0aGUgY29udGFpbmVyIHNob3VsZCBzY3JvbGxcbiAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IHNjcm9sbFdpZHRoID4gcGFyZW50V2lkdGg7XG4gICAgICAgIGNvbnN0IHVzZVBhcmVudFdpZHRoID0gdGhpcy5vcHRpb25zLmZpbGxQYXJlbnQgJiYgIXRoaXMuaXNTY3JvbGxpbmc7XG4gICAgICAgIC8vIFdpZHRoIG9mIHRoZSB3YXZlZm9ybSBpbiBwaXhlbHNcbiAgICAgICAgY29uc3Qgd2lkdGggPSAodXNlUGFyZW50V2lkdGggPyBwYXJlbnRXaWR0aCA6IHNjcm9sbFdpZHRoKSAqIHBpeGVsUmF0aW87XG4gICAgICAgIC8vIFNldCB0aGUgd2lkdGggb2YgdGhlIHdyYXBwZXJcbiAgICAgICAgdGhpcy53cmFwcGVyLnN0eWxlLndpZHRoID0gdXNlUGFyZW50V2lkdGggPyAnMTAwJScgOiBgJHtzY3JvbGxXaWR0aH1weGA7XG4gICAgICAgIC8vIFNldCBhZGRpdGlvbmFsIHN0eWxlc1xuICAgICAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5zdHlsZS5vdmVyZmxvd1ggPSB0aGlzLmlzU2Nyb2xsaW5nID8gJ2F1dG8nIDogJ2hpZGRlbic7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLmNsYXNzTGlzdC50b2dnbGUoJ25vU2Nyb2xsYmFyJywgISF0aGlzLm9wdGlvbnMuaGlkZVNjcm9sbGJhcik7XG4gICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGAke3RoaXMub3B0aW9ucy5jdXJzb3JDb2xvciB8fCB0aGlzLm9wdGlvbnMucHJvZ3Jlc3NDb2xvcn1gO1xuICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS53aWR0aCA9IGAke3RoaXMub3B0aW9ucy5jdXJzb3JXaWR0aH1weGA7XG4gICAgICAgIC8vIFJlbmRlciB0aGUgd2F2ZWZvcm1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zcGxpdENoYW5uZWxzKSB7XG4gICAgICAgICAgICAvLyBSZW5kZXIgYSB3YXZlZm9ybSBmb3IgZWFjaCBjaGFubmVsXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF1ZGlvRGF0YS5udW1iZXJPZkNoYW5uZWxzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCB0aGlzLm9wdGlvbnMuc3BsaXRDaGFubmVsc1tpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGFubmVsKFthdWRpb0RhdGEuZ2V0Q2hhbm5lbERhdGEoaSldLCBvcHRpb25zLCB3aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZW5kZXIgYSBzaW5nbGUgd2F2ZWZvcm0gZm9yIHRoZSBmaXJzdCB0d28gY2hhbm5lbHMgKGxlZnQgYW5kIHJpZ2h0KVxuICAgICAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBbYXVkaW9EYXRhLmdldENoYW5uZWxEYXRhKDApXTtcbiAgICAgICAgICAgIGlmIChhdWRpb0RhdGEubnVtYmVyT2ZDaGFubmVscyA+IDEpXG4gICAgICAgICAgICAgICAgY2hhbm5lbHMucHVzaChhdWRpb0RhdGEuZ2V0Q2hhbm5lbERhdGEoMSkpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGFubmVsKGNoYW5uZWxzLCB0aGlzLm9wdGlvbnMsIHdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmF1ZGlvRGF0YSA9IGF1ZGlvRGF0YTtcbiAgICAgICAgdGhpcy5lbWl0KCdyZW5kZXInKTtcbiAgICB9XG4gICAgcmVSZW5kZXIoKSB7XG4gICAgICAgIC8vIFJldHVybiBpZiB0aGUgd2F2ZWZvcm0gaGFzIG5vdCBiZWVuIHJlbmRlcmVkIHlldFxuICAgICAgICBpZiAoIXRoaXMuYXVkaW9EYXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBSZW1lbWJlciB0aGUgY3VycmVudCBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgY29uc3Qgb2xkQ3Vyc29yUG9zaXRpb24gPSB0aGlzLnByb2dyZXNzV3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICAgICAgLy8gU2V0IHRoZSBuZXcgem9vbSBsZXZlbCBhbmQgcmUtcmVuZGVyIHRoZSB3YXZlZm9ybVxuICAgICAgICB0aGlzLnJlbmRlcih0aGlzLmF1ZGlvRGF0YSk7XG4gICAgICAgIC8vIEFkanVzdCB0aGUgc2Nyb2xsIHBvc2l0aW9uIHNvIHRoYXQgdGhlIGN1cnNvciBzdGF5cyBpbiB0aGUgc2FtZSBwbGFjZVxuICAgICAgICBjb25zdCBuZXdDdXJzb3J0UG9zaXRpb24gPSB0aGlzLnByb2dyZXNzV3JhcHBlci5jbGllbnRXaWR0aDtcbiAgICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCArPSBuZXdDdXJzb3J0UG9zaXRpb24gLSBvbGRDdXJzb3JQb3NpdGlvbjtcbiAgICB9XG4gICAgem9vbShtaW5QeFBlclNlYykge1xuICAgICAgICB0aGlzLm9wdGlvbnMubWluUHhQZXJTZWMgPSBtaW5QeFBlclNlYztcbiAgICAgICAgdGhpcy5yZVJlbmRlcigpO1xuICAgIH1cbiAgICBzY3JvbGxJbnRvVmlldyhwcm9ncmVzcywgaXNQbGF5aW5nID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgeyBjbGllbnRXaWR0aCwgc2Nyb2xsTGVmdCwgc2Nyb2xsV2lkdGggfSA9IHRoaXMuc2Nyb2xsQ29udGFpbmVyO1xuICAgICAgICBjb25zdCBwcm9ncmVzc1dpZHRoID0gc2Nyb2xsV2lkdGggKiBwcm9ncmVzcztcbiAgICAgICAgY29uc3QgY2VudGVyID0gY2xpZW50V2lkdGggLyAyO1xuICAgICAgICBjb25zdCBtaW5TY3JvbGwgPSBpc1BsYXlpbmcgJiYgdGhpcy5vcHRpb25zLmF1dG9DZW50ZXIgJiYgIXRoaXMuaXNEcmFnZ2luZyA/IGNlbnRlciA6IGNsaWVudFdpZHRoO1xuICAgICAgICBpZiAocHJvZ3Jlc3NXaWR0aCA+IHNjcm9sbExlZnQgKyBtaW5TY3JvbGwgfHwgcHJvZ3Jlc3NXaWR0aCA8IHNjcm9sbExlZnQpIHtcbiAgICAgICAgICAgIC8vIFNjcm9sbCB0byB0aGUgY2VudGVyXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9DZW50ZXIgJiYgIXRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjdXJzb3IgaXMgaW4gdmlld3BvcnQgYnV0IG5vdCBjZW50ZXJlZCwgc2Nyb2xsIHRvIHRoZSBjZW50ZXIgc2xvd2x5XG4gICAgICAgICAgICAgICAgY29uc3QgbWluRGlmZiA9IGNlbnRlciAvIDIwO1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc1dpZHRoIC0gKHNjcm9sbExlZnQgKyBjZW50ZXIpID49IG1pbkRpZmYgJiYgcHJvZ3Jlc3NXaWR0aCA8IHNjcm9sbExlZnQgKyBjbGllbnRXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ICs9IG1pbkRpZmY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHNjcm9sbCB0byB0aGUgY2VudGVyIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgPSBwcm9ncmVzc1dpZHRoIC0gY2VudGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIC8vIFNjcm9sbCBqdXN0IGEgbGl0dGxlIGJpdCB0byBhbGxvdyBmb3Igc29tZSBzcGFjZSBiZXR3ZWVuIHRoZSBjdXJzb3IgYW5kIHRoZSBlZGdlXG4gICAgICAgICAgICAgICAgY29uc3QgZ2FwID0gMTA7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCA9XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzV2lkdGggPCBzY3JvbGxMZWZ0ID8gcHJvZ3Jlc3NXaWR0aCAtIGdhcCA6IHByb2dyZXNzV2lkdGggLSBjbGllbnRXaWR0aCArIGdhcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNjcm9sbCB0byB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIuc2Nyb2xsTGVmdCA9IHByb2dyZXNzV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1pdCB0aGUgc2Nyb2xsIGV2ZW50XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsTGVmdCB9ID0gdGhpcy5zY3JvbGxDb250YWluZXI7XG4gICAgICAgICAgICBjb25zdCBzdGFydFggPSBzY3JvbGxMZWZ0IC8gc2Nyb2xsV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBlbmRYID0gKHNjcm9sbExlZnQgKyBjbGllbnRXaWR0aCkgLyBzY3JvbGxXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc2Nyb2xsJywgc3RhcnRYLCBlbmRYKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJQcm9ncmVzcyhwcm9ncmVzcywgaXNQbGF5aW5nKSB7XG4gICAgICAgIGlmIChpc05hTihwcm9ncmVzcykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucHJvZ3Jlc3NXcmFwcGVyLnN0eWxlLndpZHRoID0gYCR7cHJvZ3Jlc3MgKiAxMDB9JWA7XG4gICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmxlZnQgPSBgJHtwcm9ncmVzcyAqIDEwMH0lYDtcbiAgICAgICAgdGhpcy5jdXJzb3Iuc3R5bGUubWFyZ2luTGVmdCA9IE1hdGgucm91bmQocHJvZ3Jlc3MgKiAxMDApID09PSAxMDAgPyBgLSR7dGhpcy5vcHRpb25zLmN1cnNvcldpZHRofXB4YCA6ICcnO1xuICAgICAgICBpZiAodGhpcy5pc1Njcm9sbGluZyAmJiB0aGlzLm9wdGlvbnMuYXV0b1Njcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldyhwcm9ncmVzcywgaXNQbGF5aW5nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblJlbmRlcmVyLk1BWF9DQU5WQVNfV0lEVEggPSA0MDAwO1xuZXhwb3J0IGRlZmF1bHQgUmVuZGVyZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/wavesurfer.js/dist/renderer.js\n"));

/***/ }),

/***/ "./node_modules/wavesurfer.js/dist/timer.js":
/*!**************************************************!*\
  !*** ./node_modules/wavesurfer.js/dist/timer.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _event_emitter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./event-emitter.js */ \"./node_modules/wavesurfer.js/dist/event-emitter.js\");\n\nclass Timer extends _event_emitter_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor() {\n        super(...arguments);\n        this.unsubscribe = () => undefined;\n    }\n    start() {\n        this.unsubscribe = this.on('tick', () => {\n            requestAnimationFrame(() => {\n                this.emit('tick');\n            });\n        });\n        this.emit('tick');\n    }\n    stop() {\n        this.unsubscribe();\n    }\n    destroy() {\n        this.unsubscribe();\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (Timer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3RpbWVyLmpzIiwibWFwcGluZ3MiOiI7O0FBQThDO0FBQzlDLG9CQUFvQix5REFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBZSxLQUFLLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3dhdmVzdXJmZXIuanMvZGlzdC90aW1lci5qcz8yNzFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi9ldmVudC1lbWl0dGVyLmpzJztcbmNsYXNzIFRpbWVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSB0aGlzLm9uKCd0aWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3RpY2snKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KCd0aWNrJyk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFRpbWVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/wavesurfer.js/dist/timer.js\n"));

/***/ }),

/***/ "./node_modules/wavesurfer.js/dist/wavesurfer.js":
/*!*******************************************************!*\
  !*** ./node_modules/wavesurfer.js/dist/wavesurfer.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _decoder_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decoder.js */ \"./node_modules/wavesurfer.js/dist/decoder.js\");\n/* harmony import */ var _fetcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fetcher.js */ \"./node_modules/wavesurfer.js/dist/fetcher.js\");\n/* harmony import */ var _player_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./player.js */ \"./node_modules/wavesurfer.js/dist/player.js\");\n/* harmony import */ var _renderer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderer.js */ \"./node_modules/wavesurfer.js/dist/renderer.js\");\n/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./timer.js */ \"./node_modules/wavesurfer.js/dist/timer.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\nconst defaultOptions = {\n    waveColor: '#999',\n    progressColor: '#555',\n    cursorWidth: 1,\n    minPxPerSec: 0,\n    fillParent: true,\n    interact: true,\n    dragToSeek: false,\n    autoScroll: true,\n    autoCenter: true,\n    sampleRate: 8000,\n};\nclass WaveSurfer extends _player_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    /** Create a new WaveSurfer instance */\n    static create(options) {\n        return new WaveSurfer(options);\n    }\n    /** Create a new WaveSurfer instance */\n    constructor(options) {\n        var _a, _b;\n        super({\n            media: options.media,\n            mediaControls: options.mediaControls,\n            autoplay: options.autoplay,\n            playbackRate: options.audioRate,\n        });\n        this.plugins = [];\n        this.decodedData = null;\n        this.subscriptions = [];\n        this.options = Object.assign({}, defaultOptions, options);\n        this.timer = new _timer_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]();\n        const audioElement = !options.media ? this.getMediaElement() : undefined;\n        this.renderer = new _renderer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.options, audioElement);\n        this.initPlayerEvents();\n        this.initRendererEvents();\n        this.initTimerEvents();\n        this.initPlugins();\n        // Load audio if URL is passed or an external media with an src\n        const url = this.options.url || ((_a = this.options.media) === null || _a === void 0 ? void 0 : _a.currentSrc) || ((_b = this.options.media) === null || _b === void 0 ? void 0 : _b.src);\n        if (url) {\n            this.load(url, this.options.peaks, this.options.duration);\n        }\n    }\n    initTimerEvents() {\n        // The timer fires every 16ms for a smooth progress animation\n        this.subscriptions.push(this.timer.on('tick', () => {\n            const currentTime = this.getCurrentTime();\n            this.renderer.renderProgress(currentTime / this.getDuration(), true);\n            this.emit('timeupdate', currentTime);\n            this.emit('audioprocess', currentTime);\n        }));\n    }\n    initPlayerEvents() {\n        this.subscriptions.push(this.onMediaEvent('timeupdate', () => {\n            const currentTime = this.getCurrentTime();\n            this.renderer.renderProgress(currentTime / this.getDuration(), this.isPlaying());\n            this.emit('timeupdate', currentTime);\n        }), this.onMediaEvent('play', () => {\n            this.emit('play');\n            this.timer.start();\n        }), this.onMediaEvent('pause', () => {\n            this.emit('pause');\n            this.timer.stop();\n        }), this.onMediaEvent('emptied', () => {\n            this.timer.stop();\n        }), this.onMediaEvent('ended', () => {\n            this.emit('finish');\n        }), this.onMediaEvent('seeking', () => {\n            this.emit('seeking', this.getCurrentTime());\n        }));\n    }\n    initRendererEvents() {\n        this.subscriptions.push(\n        // Seek on click\n        this.renderer.on('click', (relativeX) => {\n            if (this.options.interact) {\n                this.seekTo(relativeX);\n                this.emit('interaction', relativeX * this.getDuration());\n                this.emit('click', relativeX);\n            }\n        }), \n        // Scroll\n        this.renderer.on('scroll', (startX, endX) => {\n            const duration = this.getDuration();\n            this.emit('scroll', startX * duration, endX * duration);\n        }), \n        // Redraw\n        this.renderer.on('render', () => {\n            this.emit('redraw');\n        }));\n        // Drag\n        {\n            let debounce;\n            this.subscriptions.push(this.renderer.on('drag', (relativeX) => {\n                if (!this.options.interact)\n                    return;\n                // Update the visual position\n                this.renderer.renderProgress(relativeX);\n                // Set the audio position with a debounce\n                clearTimeout(debounce);\n                debounce = setTimeout(() => {\n                    this.seekTo(relativeX);\n                }, this.isPlaying() ? 0 : 200);\n                this.emit('interaction', relativeX * this.getDuration());\n                this.emit('drag', relativeX);\n            }));\n        }\n    }\n    initPlugins() {\n        var _a;\n        if (!((_a = this.options.plugins) === null || _a === void 0 ? void 0 : _a.length))\n            return;\n        this.options.plugins.forEach((plugin) => {\n            this.registerPlugin(plugin);\n        });\n    }\n    /** Set new wavesurfer options and re-render it */\n    setOptions(options) {\n        this.options = Object.assign({}, this.options, options);\n        this.renderer.setOptions(this.options);\n        if (options.audioRate) {\n            this.setPlaybackRate(options.audioRate);\n        }\n        if (options.mediaControls != null) {\n            this.getMediaElement().controls = options.mediaControls;\n        }\n    }\n    /** Register a wavesurfer.js plugin */\n    registerPlugin(plugin) {\n        plugin.init(this);\n        this.plugins.push(plugin);\n        // Unregister plugin on destroy\n        this.subscriptions.push(plugin.once('destroy', () => {\n            this.plugins = this.plugins.filter((p) => p !== plugin);\n        }));\n        return plugin;\n    }\n    /** For plugins only: get the waveform wrapper div */\n    getWrapper() {\n        return this.renderer.getWrapper();\n    }\n    /** Get the current scroll position in pixels */\n    getScroll() {\n        return this.renderer.getScroll();\n    }\n    /** Get all registered plugins */\n    getActivePlugins() {\n        return this.plugins;\n    }\n    loadAudio(url, blob, channelData, duration) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.emit('load', url);\n            if (this.isPlaying())\n                this.pause();\n            this.decodedData = null;\n            // Fetch the entire audio as a blob if pre-decoded data is not provided\n            if (!blob && !channelData) {\n                const onProgress = (percentage) => this.emit('loading', percentage);\n                blob = yield _fetcher_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fetchBlob(url, onProgress, this.options.fetchParams);\n            }\n            // Set the mediaelement source\n            this.setSrc(url, blob);\n            // Decode the audio data or use user-provided peaks\n            if (channelData) {\n                // Wait for the audio duration\n                // It should be a promise to allow event listeners to subscribe to the ready and decode events\n                duration =\n                    (yield Promise.resolve(duration || this.getDuration())) ||\n                        (yield new Promise((resolve) => {\n                            this.onceMediaEvent('loadedmetadata', () => resolve(this.getDuration()));\n                        })) ||\n                        (yield Promise.resolve(0));\n                this.decodedData = _decoder_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createBuffer(channelData, duration);\n            }\n            else if (blob) {\n                const arrayBuffer = yield blob.arrayBuffer();\n                this.decodedData = yield _decoder_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].decode(arrayBuffer, this.options.sampleRate);\n            }\n            this.emit('decode', this.getDuration());\n            // Render the waveform\n            if (this.decodedData) {\n                this.renderer.render(this.decodedData);\n            }\n            this.emit('ready', this.getDuration());\n        });\n    }\n    /** Load an audio file by URL, with optional pre-decoded audio data */\n    load(url, channelData, duration) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.loadAudio(url, undefined, channelData, duration);\n        });\n    }\n    /** Load an audio blob */\n    loadBlob(blob, channelData, duration) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.loadAudio('blob', blob, channelData, duration);\n        });\n    }\n    /** Zoom the waveform by a given pixels-per-second factor */\n    zoom(minPxPerSec) {\n        if (!this.decodedData) {\n            throw new Error('No audio loaded');\n        }\n        this.renderer.zoom(minPxPerSec);\n        this.emit('zoom', minPxPerSec);\n    }\n    /** Get the decoded audio data */\n    getDecodedData() {\n        return this.decodedData;\n    }\n    /** Get decoded peaks */\n    exportPeaks({ channels = 1, maxLength = 8000, precision = 10000 } = {}) {\n        if (!this.decodedData) {\n            throw new Error('The audio has not been decoded yet');\n        }\n        const channelsLen = Math.min(channels, this.decodedData.numberOfChannels);\n        const peaks = [];\n        for (let i = 0; i < channelsLen; i++) {\n            const data = this.decodedData.getChannelData(i);\n            const length = Math.min(data.length, maxLength);\n            const scale = data.length / length;\n            const sampledData = [];\n            for (let j = 0; j < length; j++) {\n                const n = Math.round(j * scale);\n                const val = data[n];\n                sampledData.push(Math.round(val * precision) / precision);\n            }\n            peaks.push(sampledData);\n        }\n        return peaks;\n    }\n    /** Get the duration of the audio in seconds */\n    getDuration() {\n        let duration = super.getDuration() || 0;\n        // Fall back to the decoded data duration if the media duration is incorrect\n        if ((duration === 0 || duration === Infinity) && this.decodedData) {\n            duration = this.decodedData.duration;\n        }\n        return duration;\n    }\n    /** Toggle if the waveform should react to clicks */\n    toggleInteraction(isInteractive) {\n        this.options.interact = isInteractive;\n    }\n    /** Seek to a percentage of audio as [0..1] (0 = beginning, 1 = end) */\n    seekTo(progress) {\n        const time = this.getDuration() * progress;\n        this.setTime(time);\n    }\n    /** Play or pause the audio */\n    playPause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.isPlaying() ? this.pause() : this.play();\n        });\n    }\n    /** Stop the audio and go to the beginning */\n    stop() {\n        this.pause();\n        this.setTime(0);\n    }\n    /** Skip N or -N seconds from the current position */\n    skip(seconds) {\n        this.setTime(this.getCurrentTime() + seconds);\n    }\n    /** Empty the waveform by loading a tiny silent audio */\n    empty() {\n        this.load('', [[0]], 0.001);\n    }\n    /** Unmount wavesurfer */\n    destroy() {\n        this.emit('destroy');\n        this.plugins.forEach((plugin) => plugin.destroy());\n        this.subscriptions.forEach((unsubscribe) => unsubscribe());\n        this.timer.destroy();\n        this.renderer.destroy();\n        super.destroy();\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (WaveSurfer);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2F2ZXN1cmZlci5qcy9kaXN0L3dhdmVzdXJmZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ21DO0FBQ0E7QUFDRjtBQUNJO0FBQ047QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtEQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMseUJBQXlCLGlEQUFLO0FBQzlCO0FBQ0EsNEJBQTRCLG9EQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxtQ0FBbUMsZ0VBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QywwREFBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvREFBb0QsSUFBSTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBZSxVQUFVLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3dhdmVzdXJmZXIuanMvZGlzdC93YXZlc3VyZmVyLmpzPzA1NGQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgRGVjb2RlciBmcm9tICcuL2RlY29kZXIuanMnO1xuaW1wb3J0IEZldGNoZXIgZnJvbSAnLi9mZXRjaGVyLmpzJztcbmltcG9ydCBQbGF5ZXIgZnJvbSAnLi9wbGF5ZXIuanMnO1xuaW1wb3J0IFJlbmRlcmVyIGZyb20gJy4vcmVuZGVyZXIuanMnO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vdGltZXIuanMnO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgd2F2ZUNvbG9yOiAnIzk5OScsXG4gICAgcHJvZ3Jlc3NDb2xvcjogJyM1NTUnLFxuICAgIGN1cnNvcldpZHRoOiAxLFxuICAgIG1pblB4UGVyU2VjOiAwLFxuICAgIGZpbGxQYXJlbnQ6IHRydWUsXG4gICAgaW50ZXJhY3Q6IHRydWUsXG4gICAgZHJhZ1RvU2VlazogZmFsc2UsXG4gICAgYXV0b1Njcm9sbDogdHJ1ZSxcbiAgICBhdXRvQ2VudGVyOiB0cnVlLFxuICAgIHNhbXBsZVJhdGU6IDgwMDAsXG59O1xuY2xhc3MgV2F2ZVN1cmZlciBleHRlbmRzIFBsYXllciB7XG4gICAgLyoqIENyZWF0ZSBhIG5ldyBXYXZlU3VyZmVyIGluc3RhbmNlICovXG4gICAgc3RhdGljIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgV2F2ZVN1cmZlcihvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZSBhIG5ldyBXYXZlU3VyZmVyIGluc3RhbmNlICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBtZWRpYTogb3B0aW9ucy5tZWRpYSxcbiAgICAgICAgICAgIG1lZGlhQ29udHJvbHM6IG9wdGlvbnMubWVkaWFDb250cm9scyxcbiAgICAgICAgICAgIGF1dG9wbGF5OiBvcHRpb25zLmF1dG9wbGF5LFxuICAgICAgICAgICAgcGxheWJhY2tSYXRlOiBvcHRpb25zLmF1ZGlvUmF0ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLmRlY29kZWREYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy50aW1lciA9IG5ldyBUaW1lcigpO1xuICAgICAgICBjb25zdCBhdWRpb0VsZW1lbnQgPSAhb3B0aW9ucy5tZWRpYSA/IHRoaXMuZ2V0TWVkaWFFbGVtZW50KCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIodGhpcy5vcHRpb25zLCBhdWRpb0VsZW1lbnQpO1xuICAgICAgICB0aGlzLmluaXRQbGF5ZXJFdmVudHMoKTtcbiAgICAgICAgdGhpcy5pbml0UmVuZGVyZXJFdmVudHMoKTtcbiAgICAgICAgdGhpcy5pbml0VGltZXJFdmVudHMoKTtcbiAgICAgICAgdGhpcy5pbml0UGx1Z2lucygpO1xuICAgICAgICAvLyBMb2FkIGF1ZGlvIGlmIFVSTCBpcyBwYXNzZWQgb3IgYW4gZXh0ZXJuYWwgbWVkaWEgd2l0aCBhbiBzcmNcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5vcHRpb25zLnVybCB8fCAoKF9hID0gdGhpcy5vcHRpb25zLm1lZGlhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudFNyYykgfHwgKChfYiA9IHRoaXMub3B0aW9ucy5tZWRpYSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNyYyk7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZCh1cmwsIHRoaXMub3B0aW9ucy5wZWFrcywgdGhpcy5vcHRpb25zLmR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0VGltZXJFdmVudHMoKSB7XG4gICAgICAgIC8vIFRoZSB0aW1lciBmaXJlcyBldmVyeSAxNm1zIGZvciBhIHNtb290aCBwcm9ncmVzcyBhbmltYXRpb25cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2godGhpcy50aW1lci5vbigndGljaycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5nZXRDdXJyZW50VGltZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXJQcm9ncmVzcyhjdXJyZW50VGltZSAvIHRoaXMuZ2V0RHVyYXRpb24oKSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3RpbWV1cGRhdGUnLCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2F1ZGlvcHJvY2VzcycsIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBpbml0UGxheWVyRXZlbnRzKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLm9uTWVkaWFFdmVudCgndGltZXVwZGF0ZScsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGhpcy5nZXRDdXJyZW50VGltZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXJQcm9ncmVzcyhjdXJyZW50VGltZSAvIHRoaXMuZ2V0RHVyYXRpb24oKSwgdGhpcy5pc1BsYXlpbmcoKSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3RpbWV1cGRhdGUnLCBjdXJyZW50VGltZSk7XG4gICAgICAgIH0pLCB0aGlzLm9uTWVkaWFFdmVudCgncGxheScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncGxheScpO1xuICAgICAgICAgICAgdGhpcy50aW1lci5zdGFydCgpO1xuICAgICAgICB9KSwgdGhpcy5vbk1lZGlhRXZlbnQoJ3BhdXNlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICAgICAgICAgICAgdGhpcy50aW1lci5zdG9wKCk7XG4gICAgICAgIH0pLCB0aGlzLm9uTWVkaWFFdmVudCgnZW1wdGllZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGltZXIuc3RvcCgpO1xuICAgICAgICB9KSwgdGhpcy5vbk1lZGlhRXZlbnQoJ2VuZGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgfSksIHRoaXMub25NZWRpYUV2ZW50KCdzZWVraW5nJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzZWVraW5nJywgdGhpcy5nZXRDdXJyZW50VGltZSgpKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBpbml0UmVuZGVyZXJFdmVudHMoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgICAvLyBTZWVrIG9uIGNsaWNrXG4gICAgICAgIHRoaXMucmVuZGVyZXIub24oJ2NsaWNrJywgKHJlbGF0aXZlWCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbnRlcmFjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vla1RvKHJlbGF0aXZlWCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpbnRlcmFjdGlvbicsIHJlbGF0aXZlWCAqIHRoaXMuZ2V0RHVyYXRpb24oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjbGljaycsIHJlbGF0aXZlWCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLCBcbiAgICAgICAgLy8gU2Nyb2xsXG4gICAgICAgIHRoaXMucmVuZGVyZXIub24oJ3Njcm9sbCcsIChzdGFydFgsIGVuZFgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5nZXREdXJhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzY3JvbGwnLCBzdGFydFggKiBkdXJhdGlvbiwgZW5kWCAqIGR1cmF0aW9uKTtcbiAgICAgICAgfSksIFxuICAgICAgICAvLyBSZWRyYXdcbiAgICAgICAgdGhpcy5yZW5kZXJlci5vbigncmVuZGVyJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWRyYXcnKTtcbiAgICAgICAgfSkpO1xuICAgICAgICAvLyBEcmFnXG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBkZWJvdW5jZTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKHRoaXMucmVuZGVyZXIub24oJ2RyYWcnLCAocmVsYXRpdmVYKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuaW50ZXJhY3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHZpc3VhbCBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyUHJvZ3Jlc3MocmVsYXRpdmVYKTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIGF1ZGlvIHBvc2l0aW9uIHdpdGggYSBkZWJvdW5jZVxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChkZWJvdW5jZSk7XG4gICAgICAgICAgICAgICAgZGVib3VuY2UgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWVrVG8ocmVsYXRpdmVYKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLmlzUGxheWluZygpID8gMCA6IDIwMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpbnRlcmFjdGlvbicsIHJlbGF0aXZlWCAqIHRoaXMuZ2V0RHVyYXRpb24oKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkcmFnJywgcmVsYXRpdmVYKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0UGx1Z2lucygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoISgoX2EgPSB0aGlzLm9wdGlvbnMucGx1Z2lucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMub3B0aW9ucy5wbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlclBsdWdpbihwbHVnaW4pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIFNldCBuZXcgd2F2ZXN1cmZlciBvcHRpb25zIGFuZCByZS1yZW5kZXIgaXQgKi9cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLmF1ZGlvUmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRQbGF5YmFja1JhdGUob3B0aW9ucy5hdWRpb1JhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm1lZGlhQ29udHJvbHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5nZXRNZWRpYUVsZW1lbnQoKS5jb250cm9scyA9IG9wdGlvbnMubWVkaWFDb250cm9scztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmVnaXN0ZXIgYSB3YXZlc3VyZmVyLmpzIHBsdWdpbiAqL1xuICAgIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbikge1xuICAgICAgICBwbHVnaW4uaW5pdCh0aGlzKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgICAgLy8gVW5yZWdpc3RlciBwbHVnaW4gb24gZGVzdHJveVxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChwbHVnaW4ub25jZSgnZGVzdHJveScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucGx1Z2lucy5maWx0ZXIoKHApID0+IHAgIT09IHBsdWdpbik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHBsdWdpbjtcbiAgICB9XG4gICAgLyoqIEZvciBwbHVnaW5zIG9ubHk6IGdldCB0aGUgd2F2ZWZvcm0gd3JhcHBlciBkaXYgKi9cbiAgICBnZXRXcmFwcGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5nZXRXcmFwcGVyKCk7XG4gICAgfVxuICAgIC8qKiBHZXQgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGluIHBpeGVscyAqL1xuICAgIGdldFNjcm9sbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0U2Nyb2xsKCk7XG4gICAgfVxuICAgIC8qKiBHZXQgYWxsIHJlZ2lzdGVyZWQgcGx1Z2lucyAqL1xuICAgIGdldEFjdGl2ZVBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsdWdpbnM7XG4gICAgfVxuICAgIGxvYWRBdWRpbyh1cmwsIGJsb2IsIGNoYW5uZWxEYXRhLCBkdXJhdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdsb2FkJywgdXJsKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUGxheWluZygpKVxuICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb2RlZERhdGEgPSBudWxsO1xuICAgICAgICAgICAgLy8gRmV0Y2ggdGhlIGVudGlyZSBhdWRpbyBhcyBhIGJsb2IgaWYgcHJlLWRlY29kZWQgZGF0YSBpcyBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgIGlmICghYmxvYiAmJiAhY2hhbm5lbERhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvblByb2dyZXNzID0gKHBlcmNlbnRhZ2UpID0+IHRoaXMuZW1pdCgnbG9hZGluZycsIHBlcmNlbnRhZ2UpO1xuICAgICAgICAgICAgICAgIGJsb2IgPSB5aWVsZCBGZXRjaGVyLmZldGNoQmxvYih1cmwsIG9uUHJvZ3Jlc3MsIHRoaXMub3B0aW9ucy5mZXRjaFBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdGhlIG1lZGlhZWxlbWVudCBzb3VyY2VcbiAgICAgICAgICAgIHRoaXMuc2V0U3JjKHVybCwgYmxvYik7XG4gICAgICAgICAgICAvLyBEZWNvZGUgdGhlIGF1ZGlvIGRhdGEgb3IgdXNlIHVzZXItcHJvdmlkZWQgcGVha3NcbiAgICAgICAgICAgIGlmIChjaGFubmVsRGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBhdWRpbyBkdXJhdGlvblxuICAgICAgICAgICAgICAgIC8vIEl0IHNob3VsZCBiZSBhIHByb21pc2UgdG8gYWxsb3cgZXZlbnQgbGlzdGVuZXJzIHRvIHN1YnNjcmliZSB0byB0aGUgcmVhZHkgYW5kIGRlY29kZSBldmVudHNcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCBQcm9taXNlLnJlc29sdmUoZHVyYXRpb24gfHwgdGhpcy5nZXREdXJhdGlvbigpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh5aWVsZCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25jZU1lZGlhRXZlbnQoJ2xvYWRlZG1ldGFkYXRhJywgKCkgPT4gcmVzb2x2ZSh0aGlzLmdldER1cmF0aW9uKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHlpZWxkIFByb21pc2UucmVzb2x2ZSgwKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVkRGF0YSA9IERlY29kZXIuY3JlYXRlQnVmZmVyKGNoYW5uZWxEYXRhLCBkdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChibG9iKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSB5aWVsZCBibG9iLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvZGVkRGF0YSA9IHlpZWxkIERlY29kZXIuZGVjb2RlKGFycmF5QnVmZmVyLCB0aGlzLm9wdGlvbnMuc2FtcGxlUmF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZScsIHRoaXMuZ2V0RHVyYXRpb24oKSk7XG4gICAgICAgICAgICAvLyBSZW5kZXIgdGhlIHdhdmVmb3JtXG4gICAgICAgICAgICBpZiAodGhpcy5kZWNvZGVkRGF0YSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuZGVjb2RlZERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkeScsIHRoaXMuZ2V0RHVyYXRpb24oKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogTG9hZCBhbiBhdWRpbyBmaWxlIGJ5IFVSTCwgd2l0aCBvcHRpb25hbCBwcmUtZGVjb2RlZCBhdWRpbyBkYXRhICovXG4gICAgbG9hZCh1cmwsIGNoYW5uZWxEYXRhLCBkdXJhdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5sb2FkQXVkaW8odXJsLCB1bmRlZmluZWQsIGNoYW5uZWxEYXRhLCBkdXJhdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogTG9hZCBhbiBhdWRpbyBibG9iICovXG4gICAgbG9hZEJsb2IoYmxvYiwgY2hhbm5lbERhdGEsIGR1cmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmxvYWRBdWRpbygnYmxvYicsIGJsb2IsIGNoYW5uZWxEYXRhLCBkdXJhdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogWm9vbSB0aGUgd2F2ZWZvcm0gYnkgYSBnaXZlbiBwaXhlbHMtcGVyLXNlY29uZCBmYWN0b3IgKi9cbiAgICB6b29tKG1pblB4UGVyU2VjKSB7XG4gICAgICAgIGlmICghdGhpcy5kZWNvZGVkRGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhdWRpbyBsb2FkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlcmVyLnpvb20obWluUHhQZXJTZWMpO1xuICAgICAgICB0aGlzLmVtaXQoJ3pvb20nLCBtaW5QeFBlclNlYyk7XG4gICAgfVxuICAgIC8qKiBHZXQgdGhlIGRlY29kZWQgYXVkaW8gZGF0YSAqL1xuICAgIGdldERlY29kZWREYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVkRGF0YTtcbiAgICB9XG4gICAgLyoqIEdldCBkZWNvZGVkIHBlYWtzICovXG4gICAgZXhwb3J0UGVha3MoeyBjaGFubmVscyA9IDEsIG1heExlbmd0aCA9IDgwMDAsIHByZWNpc2lvbiA9IDEwMDAwIH0gPSB7fSkge1xuICAgICAgICBpZiAoIXRoaXMuZGVjb2RlZERhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGF1ZGlvIGhhcyBub3QgYmVlbiBkZWNvZGVkIHlldCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYW5uZWxzTGVuID0gTWF0aC5taW4oY2hhbm5lbHMsIHRoaXMuZGVjb2RlZERhdGEubnVtYmVyT2ZDaGFubmVscyk7XG4gICAgICAgIGNvbnN0IHBlYWtzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbm5lbHNMZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZGVjb2RlZERhdGEuZ2V0Q2hhbm5lbERhdGEoaSk7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1pbihkYXRhLmxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gZGF0YS5sZW5ndGggLyBsZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVkRGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLnJvdW5kKGogKiBzY2FsZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gZGF0YVtuXTtcbiAgICAgICAgICAgICAgICBzYW1wbGVkRGF0YS5wdXNoKE1hdGgucm91bmQodmFsICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZWFrcy5wdXNoKHNhbXBsZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGVha3M7XG4gICAgfVxuICAgIC8qKiBHZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBhdWRpbyBpbiBzZWNvbmRzICovXG4gICAgZ2V0RHVyYXRpb24oKSB7XG4gICAgICAgIGxldCBkdXJhdGlvbiA9IHN1cGVyLmdldER1cmF0aW9uKCkgfHwgMDtcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHRoZSBkZWNvZGVkIGRhdGEgZHVyYXRpb24gaWYgdGhlIG1lZGlhIGR1cmF0aW9uIGlzIGluY29ycmVjdFxuICAgICAgICBpZiAoKGR1cmF0aW9uID09PSAwIHx8IGR1cmF0aW9uID09PSBJbmZpbml0eSkgJiYgdGhpcy5kZWNvZGVkRGF0YSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmRlY29kZWREYXRhLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkdXJhdGlvbjtcbiAgICB9XG4gICAgLyoqIFRvZ2dsZSBpZiB0aGUgd2F2ZWZvcm0gc2hvdWxkIHJlYWN0IHRvIGNsaWNrcyAqL1xuICAgIHRvZ2dsZUludGVyYWN0aW9uKGlzSW50ZXJhY3RpdmUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmludGVyYWN0ID0gaXNJbnRlcmFjdGl2ZTtcbiAgICB9XG4gICAgLyoqIFNlZWsgdG8gYSBwZXJjZW50YWdlIG9mIGF1ZGlvIGFzIFswLi4xXSAoMCA9IGJlZ2lubmluZywgMSA9IGVuZCkgKi9cbiAgICBzZWVrVG8ocHJvZ3Jlc3MpIHtcbiAgICAgICAgY29uc3QgdGltZSA9IHRoaXMuZ2V0RHVyYXRpb24oKSAqIHByb2dyZXNzO1xuICAgICAgICB0aGlzLnNldFRpbWUodGltZSk7XG4gICAgfVxuICAgIC8qKiBQbGF5IG9yIHBhdXNlIHRoZSBhdWRpbyAqL1xuICAgIHBsYXlQYXVzZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUGxheWluZygpID8gdGhpcy5wYXVzZSgpIDogdGhpcy5wbGF5KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogU3RvcCB0aGUgYXVkaW8gYW5kIGdvIHRvIHRoZSBiZWdpbm5pbmcgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIHRoaXMuc2V0VGltZSgwKTtcbiAgICB9XG4gICAgLyoqIFNraXAgTiBvciAtTiBzZWNvbmRzIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24gKi9cbiAgICBza2lwKHNlY29uZHMpIHtcbiAgICAgICAgdGhpcy5zZXRUaW1lKHRoaXMuZ2V0Q3VycmVudFRpbWUoKSArIHNlY29uZHMpO1xuICAgIH1cbiAgICAvKiogRW1wdHkgdGhlIHdhdmVmb3JtIGJ5IGxvYWRpbmcgYSB0aW55IHNpbGVudCBhdWRpbyAqL1xuICAgIGVtcHR5KCkge1xuICAgICAgICB0aGlzLmxvYWQoJycsIFtbMF1dLCAwLjAwMSk7XG4gICAgfVxuICAgIC8qKiBVbm1vdW50IHdhdmVzdXJmZXIgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zLmZvckVhY2goKHBsdWdpbikgPT4gcGx1Z2luLmRlc3Ryb3koKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKCh1bnN1YnNjcmliZSkgPT4gdW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIHRoaXMudGltZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFdhdmVTdXJmZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/wavesurfer.js/dist/wavesurfer.js\n"));

/***/ })

});